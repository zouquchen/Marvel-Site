---
title: MySQL日志
date: 2022-07-13 19:26:43
permalink: /pages/efba4b/
categories:
  - 计算机基础
  - MySQL
tags:
  - 
author: 
  name: Marvel
  link: https://github.com/zouquchen
---
# MySQL日志

MySQL日志包括：误日志、查询日志、慢查询日志、事务日志、二进制日志几大类。其中比较重要的日志为以下三个：

- `bin log`：二进制日志（归档日志）
- `redo log`：事务日志（重做日志）
- `undo log`：回滚日志

#### 1 重做日志 redo log

InnoDB存储引擎以页（16KB）为单位来存储管理空间，真正访问页面之前，需要先把磁盘中的数据加载到内存的Buffer Pool之中才可以访问。如果我门只在内存的Buffer Pool中修改页面并提交事务，如果此时出现故障导致宕机，数据库中的数据将会丢失。但是，当我们每次提交事物后，都将数据页刷新到磁盘是非常低效的。因为：① 刷新一个完整的数据页太浪费，因为即使只修改一个字节也要刷新16KB的数据到磁盘；② 随机I/O刷新起来比较慢，一个事务包含很多语句，且这些语句对应的数据页不相邻，需要多次随机I/O。

因此，我们不需要在每次提交事务时就把该事务在内存中修改过的全部数据刷新到磁盘，只需把修改的内存记录一下就好，这就是redo log。redo log占用的空间非常小，且是顺序写入磁盘，每执行一条语句，产生的若干条日志都是按产生顺序写入磁盘。当系统崩溃重启后，可以使用redo log的记录更新数据页。

![image-20220713193010552](https://raw.githubusercontent.com/zouquchen/Images/main/imgs/image-20220713193010552.png)

#### 2 Buffer Pool

MySQL中数据以页为单位，你查询一条记录，会从硬盘中读取出一页的数据，加载出来的数据叫数据页，会放到Buffer Pool中。后续的查询都是先从Buffer Pool中找，没有命中再去硬盘加载，减少硬盘IO开销，提升性能。

更新表数据的时候，也是如此，发现Buffer Pool里存在要更新的数据，就直接在Buffer Pool里更新。

然后再把“在某个数据页上做了什么修改”记录到重做日志缓存（redo log buffer）里，接着刷盘到redo log文件里。

<img src="https://raw.githubusercontent.com/zouquchen/Images/main/imgs/03.png" alt="img" style="zoom:67%;" />

理想情况，事务提交就会进行刷盘操作，但实际上，刷盘的实际是根据策略来进行的。

#### 3 刷盘时机

redo log的刷盘策略有三种，可通过`innodb_flush_log_at_trx_commit`参数进行设置

- 0：每次事务提交时不进行刷盘操作
- 1：每次事务提交时都进性刷盘操作（默认值）
- 2：每次事务提交时都只把redo log buffer内容写进page cache

#### 4 日志文件组

硬盘上存储的redo log日志不止一个，而是以一个**日志文件组**的形式存在的，每个redo日志文件大小都是一样的。

比如可以配置为一组4个文件，每个文件的大小时1GB，整个redo log日志文件组可以记录4G内容。它采用的是环形数组形式，从头开始写，写到末尾又回到头循环写，如下图所示。

![img](https://raw.githubusercontent.com/zouquchen/Images/main/imgs/10.png)

#### 7 bin log

redo log是物理日志，bin log是逻辑日志，记录内容是语句的原始逻辑，类似于“给ID=2这一行的c字段加1”，属于MySQL Server层。

数据库的数据备份、主备、主主、主从都离不开binlog，需要binlog来同步数据，保证数据的一致性。



#### 8 两阶段提交

> redo log让InnoDB存储引擎拥有崩溃恢复的能力。
>
> bin log保证MySQL集群架构的数据一致性。
>
> 在执行更新语句过程，会记录redo log与bin log两块日志，以基本的事务为单位，redo log在事务执行过程中可以不断写入，而bin log只有在提交事务时才写入。

<img src="https://raw.githubusercontent.com/zouquchen/Images/main/imgs/01-20220305234816065.png" alt="img" style="zoom:50%;" />

为了解决两份日志之间的逻辑一致问题，InnoDB存储引擎使用两阶段提交方案，将redo log的写入拆分成两个步骤prepare和commit。

<img src="https://raw.githubusercontent.com/zouquchen/Images/main/imgs/04-20220305234956774.png" alt="img" style="zoom:67%;" />

使用两阶段提交后，写入binlog时发生异常，因为MySQL根据redo log日志恢复数据时，发现redo log还处于prepare阶段，并且没有对应bin log日志，就会回滚该事务。

#### 9 回滚日志undo log 

要想保证事务的原子性，就需要在异常发生时，对已经执行的操作进行回滚，在MySQL中，恢复机制时通过回滚日志实现的。

所有事务进行的修改都会先记录到整个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，就直接利用回滚日志中的信息将数据回滚到修改之前的样子即可。并且回滚日志会优先于数据持久化。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚之前未完成的事务。