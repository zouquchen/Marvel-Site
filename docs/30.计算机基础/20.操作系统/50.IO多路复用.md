# IO多路复用

为什么要了解 IO 多路复用技术呢？

1. 面试中会考；
2. 在 redis、nginx 以及 Java NIO 中都有使用，必要了解一下。



## 问题引出

🔊 **问题**：

如何设计一个高性能的网络服务器，可以供多个客户端同时连接，并且能处理这些客户端传上来的请求呢？



🙋‍♂️ **方案1**：

使用多线程，每一个线程处理一个请求。但需要 CPU 的上下文切换，当请求特别多的时候效率低。



🙋‍♂️ **方案2**：

使用单线程，在说明解决方法之前我们要知道：

1. 使用单线程时，当一个线程正在处理 A 的请求时，B 发送上来的数据也不会丢失，因为在网卡里有 DMA，它可以在不需要 CPU 的情况下将数据写入到内存当中。

2. 在 Linux 系统中每一个网络连接都是一个文件，在内核中以文件描述符（fd）的形式存在。

我们可以采用下面的方案，把所有文件描述符放到一个数组中进行遍历，如果遍历到某一个文件描述符可以读取数据，那么就执行读取数据的操作。

```
while(1) {
	for (Fdx in [FdA, FdB, ..., Fdn, ...]) {
		if (Fdx 有数据) {
			读取Fdx数据;
			处理数据;
		}
	}
}
```

虽然可以解决问题，但是它的性能依然不够好，因为它是用我们的程序判断的，并不是从操作系统底层解决的问题。



## select

### select 的作用

在 Linux 中，我们可以使用 select 函数实现 I/O 端口的复用，传递给 select 函数的参数会告诉内核：

1. 我们所关心的文件描述符
2. 对每个描述符，我们所关心的状态。
3. 我们要等待多长时间。

从select函数返回后，内核告诉我们以下信息:

1. 对我们的要求已经做好准备的描述符的个数
2. 对于三种条件哪些描述符已经做好准备（读，写，异常）

有了这些返回信息，我们可以调用合适的 I/O 函数（通常是 read 或 write），并且这些函数不会再阻塞。

### select API 说明

**函数接口**：

```cpp
#include <sys/select.h>
int select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset, struct timeval *timeout);
```

⭐ **返回值**

做好准备的文件描述符的个数，超时为 0，错误为 -1

⭐ **maxfdp1**

整型数，指数组中所有文件描述符的范围，最大的文件描述符的值加 1

⭐  **set**

中间三个参数指向描述符集，指明了我们关心那些描述符，并需要满足哪些条件（可写，可读，异常），我们只需理解 readset，只考虑哪些文件描述符已经做好被读的准备了

⭐ **timeout**

它指明我们要等待的时间:

```
struct timeval {
    long tv_ sec; /*秒 */
    long tv_ usec; /*微秒*/
}
```

有三种情况:

1. `timeout == NULL` 等待无限长的时间。
2. `timeout->tv_ sec == 0 && timeout->tv _usec == 0` 不等待，直接返回。(非阻塞)
3. `timeout->tv sec !=0 || timeout->tv_ usec!= 0` 等待指定的时间。

### 操作 Fds API

```cpp
/* 将fd_set的所有位都设为0 */
int FD_ZERO(fd_set *fdset);

/* 清除某个位 */
int FD_CLR(int fd, fd_set *fdset);

/* 将指定位置的bit值设置为1 */
int FD_SET(int fd, fd_set *fdset);

/* 测试某个位是否被置位 */
int FD_ISSET(int fd, fd_set *fdset);
```

### 举例说明

我们以下面这段代码为案例来详细了解 select，我们将逐步分析每一部分

```cpp
sockfd = socket(AF_INET, SOCK_STREAM, 0);
memset(&addr, 0, sizeof (addr));
addr.sin_family = AF_INET;
addr.sin_port = htons(2000);
addr.sin_addr.s_addr = INADDR_ANY;
bind(sockfd,(struct sockaddr*)&addr ,sizeof(addr));
listen (sockfd, 5); 

for (i=0;i<5;i++) 
{
    memset(&client, 0, sizeof (client));
    addrlen = sizeof(client);
    fds[i] = accept(sockfd,(struct sockaddr*)&client, &addrlen);
    if(fds[i] > max)
        max = fds[i];
}

while(1){
    FD_ZERO(&rset);
    for (i = 0; i< 5; i++ ) {
        FD_SET(fds[i],&rset);
    }

    puts("round again");
    select(max+1, &rset, NULL, NULL, NULL);

    for(i=0;i<5;i++) {
        if (FD_ISSET(fds[i], &rset)){
            memset(buffer,0,MAXBUF);
            read(fds[i], buffer, MAXBUF);
            puts(buffer);
        }
    }	
}
```

⭐ **第一部分**：准备文件描述符数组 fds

```cpp
sockfd = socket(AF_INET, SOCK_STREAM, 0);
memset(&addr, 0, sizeof (addr));
addr.sin_family = AF_INET;
addr.sin_port = htons(2000);
addr.sin_addr.s_addr = INADDR_ANY;
bind(sockfd,(struct sockaddr*)&addr ,sizeof(addr));
listen (sockfd, 5); 
for (i=0;i<5;i++) 
{
    memset(&client, 0, sizeof (client));
    addrlen = sizeof(client);
    // 文件描述符存储到 fds 中，每个文件描述就是一个随机的数字（编号）
    fds[i] = accept(sockfd,(struct sockaddr*)&client, &addrlen);
    // 求出最大的文件描述符编号
    if(fds[i] > max)
        max = fds[i];
}
```

这部分代码只需要浅浅的了解一下就好了，我们只要知道这几点即可：

1. fds 是用于存储文件描述符的数组
2. 每一个文件描述符是一个随机的数字（编号）
3. max 记录了这些文件描述符中编号最大的值

因为一共建立了 5 个 socket 连接，所以数组的大小为 5。我们可以假设这 5 个文件描述符的编号为1、2、5、7、9

<img src="https://raw.githubusercontent.com/zouquchen/Images/main/imgs/IO-select1.png" alt="image-20220725211759186"  />

⭐ **第二部分**：调用 select 方法

> 下面代码中使用的 API 在前面都已经介绍了，看不懂的 API 可以再去前面看看

```cpp
while(1){
    // 这里的 rset 集合会反复使用，每次使用之前要全部置 0
    FD_ZERO(&rset);
    for (i = 0; i< 5; i++ ) {
        FD_SET(fds[i],&rset);
    }
    ...
}
```

rset 就是即将传入 select 方法中的 readset，它的数据结构是 bitmap，默认大小为 1024。因为它会在每一次循环中反复使用，所以在每一次使用之前都会调用 `FD_ZERO()` 方法将 rset 位图中的所有位都清零，这个 API 在前面介绍过。

通过一个 for 循环，我们将 fds 数组转换成我们需要的 rset 位图：

![image-20220725212704773](https://raw.githubusercontent.com/zouquchen/Images/main/imgs/IO-select2.png)

下面开始调用 `select()` 方法

```cpp
while(1){
    // 这里的 rset 集合会反复使用，每次使用之前要全部置 0
    FD_ZERO(&rset);
    for (i = 0; i< 5; i++ ) {
        FD_SET(fds[i],&rset);
    }

    puts("round again");
    // 调用 select 方法，这里我们只关心读，而不关注写和异常，所以只是传入了 readset 的值
    // 判断哪些文件已经做好读的准备了
    // 超时时间设置为 null，等待无限长时间
    select(max+1, &rset, NULL, NULL, NULL);  // 没有数据准备好，将一直阻塞在这里
    ...
}
```

前面我们介绍了 `select()` 方法的 API，这里我们只关心读，而不关心写和异常，所以只传入了 readset 位图，用于判断哪些文件做好了读的准备；超时时间为 null，等待无限长时间。

select 的执行流程如下，先把用户态的 rset 复制到 内核态中，在内核态中判断文件描述符是否读取好数据。内核态的判断比用户态效率高，因为用户态的判断也是要通过内核态。如果没有数据准备好，内核态将一直判断，select 函数将一直阻塞在那里。

由于 rset 的位数为 1024，我们只用了其中的 0 到 9 位，遍历剩下的 1000 多位都是浪费，我们可以通过 `max + 1` 指明我们只需要遍历到 `max + 1` 位即可，后面的数据不需进行遍历。 

![image-20220725220026518](https://raw.githubusercontent.com/zouquchen/Images/main/imgs/IO-select3.png)

当有数据到来时，内核会将有数据的 fd 置位，表示已经有数据来了（rset 中已经置 1 了，这个地方怎么实现的置位，我不太请），之后 select 将返回，程序将继续向下运行。

```cpp
while(1){
    // 这里的 rset 集合会反复使用，每次使用之前要全部置 0
    FD_ZERO(&rset);
    for (i = 0; i< 5; i++ ) {
        FD_SET(fds[i],&rset);
    }

    puts("round again");
    // 调用 select 方法，这里我们只关心读，而不关注写和异常，所以只是传入了 readset 的值
    // 判断哪些文件已经做好读的准备了
    // 超时时间设置为 null，等待无限长时间
    select(max+1, &rset, NULL, NULL, NULL);  // 没有数据准备好，将一直阻塞在这里
    for(i=0;i<5;i++) {
        // 遍历 fds，根据 rset 判断哪些数据可以读取了
        if (FD_ISSET(fds[i], &rset)){
            // 下面处理数据
            memset(buffer,0,MAXBUF);
            read(fds[i], buffer, MAXBUF);
            puts(buffer);
        }
    }	
}
```

遍历 fds，根据 rset 判断哪些数据可以读取了，然后对这些数据进行读取和处理。

### select 总结

我们将全部的文件描述符收集过来交给内核去处理，内核帮我们遍历哪些数据已经准备好了，当其中一个或多个数据准备好后，select函数会返回，并且有数据的 fd 会置位。返回之后，我们开始遍历数据，根据 rset 来判断哪些数据已经准备好了，并且对准备好的数据进行读取和处理。

提高效率的原因是：将 fd 交给内核去处理，内核处理好后再告诉用户来读取和处理。

select 的缺点：

1. rset 位图的默认大小为 1024，处理的数量有上限
2. rset 不可重用，每一次使用都需要清零，再通过 fds 数组进行置位
3. rset 从用户态拷贝到内核态需要开销
4. select 返会后我们知道其中已经有 fd 处于有数据的状态，但是我们不知道哪个或哪几个有数据，我们还需要去遍历所有 fd，时间复杂度为 O(n)



## poll





```cpp
for (i=0;i<5;i++) 
{
    memset(&client, 0, sizeof (client));
    addrlen = sizeof(client);
    pollfds[i].fd = accept(sockfd,(struct sockaddr*)&client, &addrlen);
    pollfds[i].events = POLLIN;
}
sleep(1);
while(1){
    puts("round again");
    poll(pollfds, 5, 50000);

    for(i=0;i<5;i++) {
        if (pollfds[i].revents & POLLIN){
            pollfds[i].revents = 0;
            memset(buffer,0,MAXBUF);
            read(pollfds[i].fd, buffer, MAXBUF);
            puts(buffer);
        }
    }
}
```



## epoll

// TODO
