# Redis集群 — Redis集群

## 介绍

参考：[Redis 集群原理](https://blog.csdn.net/xueguchen/article/details/109847085)

redis 集群是一个由**多个主从节点群组**成的分布式服务器群，它具有复制、高可用和分片特性。Redis 集群不需要sentinel 哨兵也能完成节点移除和故障转移的功能。需要将每个节点设置成集群模式，这种集群模式没有中心节点，可水平扩展，据官方文档称可以线性扩展到上万个节点（官方推荐不超过1000个节点）。redis集群的性能和高可用性均优于之前版本的哨兵模式，且集群配置非常简单。

![img](https://raw.githubusercontent.com/zouquchen/Images/main/imgs/Redis-cluster1.png)

## 原理

Redis Cluster 将所有数据划分为 16384 个 slots(槽位)，每个节点负责其中一部分槽位。槽位的信息存储于每个节点中。

当 Redis Cluster 的客户端来连接集群时，它也会得到一份集群的槽位配置信息并将其缓存在客户端本地。这样当客户端要查找某个 key 时，可以直接定位到目标节点。同时因为槽位的信息可能会存在客户端与服务器不一致的情况，还需要纠正机制来实现槽位信息的校验调整。

### 槽位定位算法

Cluster 默认会对 key 值使用 crc16 算法进行 hash 得到一个整数值，然后用这个整数值对 16384 进行取模来得到具体槽位。

`HASH_SLOT = CRC16(key) mod 16384`

### 跳转重定位

当客户端向一个错误的节点发出了指令，该节点会发现指令的 key 所在的槽位并不归自己管理，这时它会向客户端发送一个特殊的跳转指令携带目标操作的节点地址，告诉客户端去连这个节点去获取数据。客户端收到指令后除了跳转到正确的节点上去操作，还会同步更新纠正本地的槽位映射表缓存，后续所有 key 将使用新的槽位映射表。

### 选举原理

当 slave 发现自己的 master 变为 FAIL 状态时，便尝试进行 Failover，来成为新的master。由于挂掉的 master 可能会有多个slave，从而存在多个slave竞争成为master节点的过程：

1. slave发现自己的master变为FAIL
2. 将自己记录的集群 currentEpoch 加 1，并广播 FAILOVER_AUTH_REQUEST 信息
3. 其他节点收到该信息，只有 master 响应，判断请求者的合法性，并发送 FAILOVER_AUTH_ACK，对每一个 epoch 只发送一次 ack
4. 尝试 failover 的 slave 收集 master 返回的 FAILOVER_AUTH_ACK
5. slave 收到超过半数 maste r的 ack 后变成新 Master
6. slave广播Pong消息通知其他集群节点

注意：从节点并不是在主节点一进入 FAIL 状态就马上尝试发起选举，而是有一定延迟，一定的延迟确保我们等待 FAIL 状态在集群中传播，slave 如果立即尝试选举，其它 masters 或许尚未意识到 FAIL 状态，可能会拒绝投票

延迟计算公式：`DELAY = 500ms + random(0 ~ 500ms) + SLAVE_RANK * 1000ms`

SLAVE_RANK 表示此 slave 已经从 master 复制数据的总量的 rank。Rank 越小代表已复制的数据越新。这种方 式下，持有最新数据的 slave 将会首先发起选举（理论上）
