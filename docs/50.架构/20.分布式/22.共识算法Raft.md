---
title: 共识算法Raft
date: 2022-07-31 14:34:35
permalink: /pages/10dcdf/
categories:
  - 架构
  - 分布式
tags:
  - 
author: 
  name: Marvel
  link: https://github.com/zouquchen
---
# 共识算法 Raft

参考视频：[解读共识算法Raft](https://www.bilibili.com/video/BV1BZ4y1U774)

该算法来源于论文[《In Search of an Understandable Consensus Algorithm》](https://raft.github.io/raft.pdf)

通过[Raft 可视化](https://raft.github.io/)更加有利于对 Raft 的理解

## Raft 简介

Raft，一个更易理解的共识算法

相比于 Paxos，Raft 的最大特性就是**利于理解**（Understandable），为了达到这个目标，Raft 主要做了两个方面的事情：

1. 问题分解：把共识算法分为三个子问题
   1. **领导选举**（leader election）
   2. **日志复制**（log replication）
   3. **安全性**（safety）
2. 状态简化：对算法做出一些限制，减少状态数量和可能产生的波动



## 复制状态机

复制状态机（Replicated state machine）的核心思想：

- 相同的初始状态 + 相同的输入 = 相同的结束状态
- 可理解为：从相同的初始状态开始，执行相同的一串命令，产生相同的最终状态。

在 Raft 中，leader 将客户端请求封装成一个个 log entry 中，将这些 log entries 复制到所有 follower 节点，然后大家按相同顺序应用 log entries 中的请求，根据复制状态机的理论，各节点的结束状态肯定一致。

<img src="https://raw.githubusercontent.com/zouquchen/Images/main/imgs/Replicated-state-machine.png" alt="Replicated-state-machine" style="zoom:50%;" />

客户端 client 给 leader 发送命令，leader 根据命令生成 log，并且发送给其他的 follower 节点，所有节点一起把 log 应用到自己的的状态机中。这时，无论 client 查询哪个节点，只要这个节点正常应用了日志，查询到的结果都是一致的。

可以说，使用共识算法就是为了实现复制状态机。一个分布式场景下的各节间就是通过共识算法来保证命令序列的一致，从而始终保持它们的状态一致，从而实现高可用。

## 状态简化

⭐ **角色**

在任意时刻，每个服务器节点都处于 Leader，Follower 或 Candidate 这三个状态之一。

<img src="https://raw.githubusercontent.com/zouquchen/Images/main/imgs/raft-state.png" alt="image-20220731151720157" style="zoom:50%;" />

任意一个节点启动时都是一个 Follower，当该节点察觉到集群中没有 Leader 的话，它会把自己的状态从 Follower 切换成 Candidate，在 Candidate 状态下经历一次或多次选举，最终根据选举的结果决定自己切换到 Leader 或 Follower 状态。

⭐ **任期**

Raft 把时间分割成任意长度的**任期**（term），用连续的整数标记。

每一段任期从一次选举开始，在一任期内，最多只有一个 leader。在某些情况下，一次选举无法选出 leader，这一任期会以没有 leader 结束。

<img src="https://raw.githubusercontent.com/zouquchen/Images/main/imgs/raft-term.png" alt="image-20220731152432978" style="zoom:50%;" />

任期的机制可以非常明确的标识集群的状态，通过任期的比较，可以确认一台服务器历史的状态。比如，可以查看一台服务器是否具有 t2 任期内的日志来判断它在 t2 时间段内是否宕机。

- 服务器之间的通信会交换当前任期号；如果一个服务器上的当前任期号比其他的小，该服务器会将自己的任期号更新为较大的值

- 如果一个 candidate 或 leader 发现称自己的任期号过期了，它会立即回到 follower 状态
- 如果一个节点接收到一个过期的任期号的请求，它会拒绝这个请求

⭐ **通信**

Raft 算法中服务器节点之间使用 RPC 进行通信，由两种主要的 RPC：

- RequestVote RPC：请求投票，由 candidate 在选举期间发起
- AppendEntries RPC：追加条目，由 leader 发起，用来复制日志和提供心跳

## 领导者选举

Raft 内部有一种心跳机制，如果存在 Leader，那么它就会周期性地向所有 Follower 发送心跳，来维持自己的地位。如果 Follower 一段时间没收到心跳，那么它就会认为系统中没有可用的 Leader 了，然后开始选举。

一个选举过程中，Follower 先增**加自己的当前任期号**，并转换到 **Candidate** 状态。然后**投票给自己**，并且并行的向集群中的其他服务节点发送投票请求（RequestVote RPC）

最终会有三种结果：

1. **自己成为 Leader**：它获得**超过半数选票**赢得选举，成为 Leader 开始发送心跳。
2. **其他节点成为 Leader**：其他节点赢得选举，它收到了新的 Leader 的心跳后，如果新 Leader 的任期号大于等于自己当前的任期号，那么从 Candidate 回到 Follower 状态。
3. **未选出 Leader**：一段时间后没有任何获胜者，每一个 Candidate 都在一个自己的「随机选举超时时间」后增加任期号开始新一轮投票，每一轮的投票都不需要和其他节点达成共识，只跟自己的「随机选举超时时间」有关。
   - 没有选出的原因：多个 Follower 同时成为 Candidate，得票太过分散，没有任何节点超过半数。
   - 论文中给出的「随机选举超时时间」为 150 ~ 300ms

⭐ **RequestVote RPC**

- 请求，由 Candidate 发起，论文中称为 Argument
  - term：int，自己当前的任期号
  - candidateId：int，自己的 ID
  - lastLogIndex：int，自己最后一个日志号
  - LastLogTerm：int，自己最后一个日志的任期
- 响应，由 Follower 回复 Candidate，论文中称为 Results
  - term：int，自己当前任期号
  - voteGranted：bool，自己会不会投给这个 Candidate

⭐ **参数解释**

- **term**：Raft 节点通过 term 来确定自身的状态，以及判断接不接收这个 RPC。如果一个节点接收到一个过期的任期号的请求，它会拒绝这个请求。
- **candidateId**：Follower 需要知道自己投票给谁
- lastLogIndex：后面介绍
- LastLogTerm：后面介绍
- **voteGranted**：Follower 收到请求后会校验这个 Candidate 是否符合条件：1. term是否比自己打；2. 后面介绍。符号条件返回 true。每个 Follower 只有一张选票，按照先来先得的原则投出。



Raft 集群启动时，所有的节点都是 Follower，当某一节点意识到集群中没有 Leader 节点时会开始竞选 Leader，它会把自己的任期号加一并发请求投票给其他 Follower，通常来说第一个意思到集群中没有 Leader 的节点具有新发优势，很大概率上会成为 Leader。在一个 Leader 任期结束或失效后，也同样会进入这样一个任期的循环。



## 日志复制

难点开始了！！！

⭐ **客户端请求**

Leader 被选举出来后，开始为客户端请求提供服务。但客户端如何知道哪个节点是 Leader 呢？

客户端随机向一个节点发起请求，会有三种情况

- 该节点为 Leader，执行指令即可
- 该节点为 Follower，该节点可以通过心跳得知 Leader 的 ID，告知客户端该找谁
- 找到的节点宕机了，即无响应，客户端再去找其他节点重复上述过程

Raft 集群中只要有超过一半的节点正常工作，那么 Raft 集群就能正常提供服务 

⭐ **日志**

Leader 接收到客户端的请求后会把相应的指令作为一个新的条目追加到日志中，日志具有三个信息，我们看图中 log index 行和 leader 行：

1. 状态机的指令，通常为对某些值进行某些操作。如图，日志 1 就是将 x 赋值为 3；
2. 任期号，用于检测多个日志副本之间的不一致以及判定节点状态。如图，方块上的数字就是任期号；
3. 日志索引，区分日志前后关系。如图，最上面的数值就是日志索引。

<img src="https://raw.githubusercontent.com/zouquchen/Images/main/imgs/raft-log.png" alt="image-20220731215221973" style="zoom: 80%;" />

由于某些节点宕机，有可能出现日志索引相同，但日志不同的日志。所以，只有日志索引和任期号两个条件才能唯一确定一个日志。

⭐ **简单情况日志复制**

Leader 并行发送追加条目请求（AppendEntries RPC） 给 Follower，让他们复制该条目。当该条目被超过半数的 Follower 复制后，Leader 就可以在本地执行该指令并把结果返回客户端。

> AppendEntries RPC 的属性后面将介绍

我们把本地执行指令，也就是 Leader 应用日志到状态机这一步称为提交。

> 只要日志复制超过半数的节点后，Leader 就一定会提交？
>
> 不是，因为 Follower 复制完成，到 Follower 通知 Leader，再到 Leader 提交，这一过程是需要时间的，这个时间内如果 Leader 宕机了，那么日志将无法提交。

上图中，第一行为 Leader，后面四行是 Follower，它们的日志复制情况各不相同，只要有 3 个及以上节点（包括 Leader）复制到了日志，Leader 就可以提交。所以途中可以提交到的日志到 7.

⭐ **复杂情况日志复制**

在日志复制过程中，Leader 和 Follower 随时都有可能崩溃或缓慢，Raft 必须要在有宕机的情况下继续支持日志复制，并且保证每个副本日志顺序的一致性。下面分三种情况讨论：

1. Follower 因为某些原因**没有给 Leader 响应**，那么 Leader 会不断地重发追加条目请求（AppendEntries RPC），即使 Leader 已经回复了客户端，但它仍不会放弃这个节点，会继续重发追加条目请求，直至 Follower 的日志追上 Leader。

2. **Follower 崩溃后恢复**，需要保证 Follower 能按顺序恢缺失的日志。

   - 与情况 1 不同的是，可能在 Follower 崩溃的期间内 Leader 发生多次变更，当前 Leader 并不知 Follower 宕机前日志复制到哪里。
   - 此时，通过一致性检查，Leader 在每一个发往 Follower 的追加条目请求中，会放入前一个日志条目的日志索引和任期号，如果 Follower 在它的日志中找不到前一个日志，那么他就会拒绝此日志，leader 收到 Follower 的拒绝后，会发送前一个日志条目，从而逐渐向前定位到 Follower 第一个缺失的日志，并按照顺序补齐所有的缺失的日志。

3. **Leader 崩溃**，那么崩溃的 Leader 可能已经复制了日志到一部分 Follower 但还没有提交。而被选出的新 Leader 又可能不具备这些日志，这样有部一分 Follower 中的日志和新 Leader 的日志不相同。

   <img src="https://raw.githubusercontent.com/zouquchen/Images/main/imgs/raft-log2.png" alt="image-20220731225103023" style="zoom:67%;" />

   1. 
