---
title: Domain-Driven Design入门
date: 2022-09-23 23:32:24
permalink: /pages/593581/
categories:
  - 架构
tags:
  - 架构
author: 
  name: Marvel
  link: https://github.com/zouquchen
---

# Domain-Driven Design入门

学习视频：[【领域驱动设计】DDD入门五板](https://www.bilibili.com/video/BV11q4y1q74f)

[驱动设计代码示例](https://nifxcrzmch.feishu.cn/docx/doxcnRYrE1SHbU7TYvFxPaNpUBc)

## 1. 介绍

Domain-Driven Design，可以基于**领域**的工程设计

**领域**：业务问题的范畴，领域可大可小，对应着大小业务问题的边界。

**领域驱动设计**：就是将业务上要做的一件大事，通过推演和抽象，拆分成多个内聚的领域。

> 有点像模块化、微服务。都是为了降低软件开发维护复杂度，遵顼解耦原则。但他们属于软件开发中不同层面的实现方式。

## 2. 举例说明

假设现在在做一个简单的数据统计系统，地推员输入客户的姓名和手机号。根据客户手机号的归属地和所属运营商，将客户群体分组，分配给相应销售组，由销售组跟进后续的业务。

根据需求，需要提供一个**注册服务**，注册服务的入参是客户的姓名和手机号。流程如下：

![DDD-example1](https://studynote-images.oss-cn-hangzhou.aliyuncs.com/DDD-example1.png)

代码实现如下：

```java
public class User {
    Long userId;
    String name;
    String phone;
    Long repId;
}

public class RegistrationServiceImpl implements RegistrationService {

    private SalesRepRepository salesRepRepo;
    private UserRepository userRepo;

    public User register(String name, String phone)
            throws ValidationException {
        // 参数校验
        if (name == null || name.length() == 0) {
            throw new ValidationException("name");
        }
        if (phone == null || !isValidPhoneNumber(phone)) {
            throw new ValidationException("phone");
        }

        // 获取手机号归属地编号和运营商编号 然后通过编号找到区域内的SalesRep
        String areaCode = getAreaCode(phone);
        String operatorCode = getOperatorCode(phone);
        SalesRep rep = salesRepRepo.findRep(areaCode, operatorCode);

        // 最后创建用户，落盘，然后返回
        User user = new User();
        user.name = name;
        user.phone = phone;

        if (rep != null) {
            user.repId = rep.repId;
        }

        return userRepo.save(user);
    }

    private boolean isValidPhoneNumber(String phone) {
        String pattern = "^0[1-9]{2,3}-?\\d{8}$";
        return phone.matches(pattern);
    }
    
    private String getAreaCode(String phone) {
        //...
    }
    
    private String getOperatorCode(String phone) {
       //...
    }
}
```

如果是一个小工程，或者迭代低频甚至短期可能下线的系统，这样写没有任何问题。但是，如果在一个迭代频繁的大工程内，存在一些隐患：

### 2.1 接口语义与参数校验

问题一：入参为两个 String 类型，编译后方法只保留了参数类型，不会保留参数名。在被调用时，很有可能 name 和 phone 写反，导致错误发生。

问题二：当前只通过 name 和 phone 进行注册，如果想通过 name 和 id 进行注册，或者通过 name、id 和 phone 进行注册，那么接口需要频繁修改，说明原来的接口定义不完善。

所以接口定义的目标：

- 语义明确无歧义，拓展性强，具有自检性
- 参数校验逻辑复用，内聚
- 参数校验异常和业务逻辑异常解耦

> 如果使用工具类在业务逻辑中进行参数校验，那么就业务将与工具类耦合起来，业务的参数异常和业务的逻辑异常也混合起来了。当参数类型越来越多，工具类中的校验逻辑也会不断膨胀，后续不利于维护。

解决方案：自定义类，包含属性与行为。PhoneNumber 中包含了属性和校验逻辑，

```java
public User register(String name, PhoneNumber phone)

public class PhoneNumber {
    private final String number;
    private final String pattern = "^0?[1-9]{2,3}-?\\d{8}$";
    
    public String getNumber() {
        return number;
    }

    // 仅存在含参构造器
    public PhoneNumber(String number) {
        if (number == null) {
            throw new ValidationException("number不能为空");
        } else if (isValid(number)) {
            throw new ValidationException("number格式错误");
        }
        this.number = number;
    }

    private boolean isValid(String number) {
        return number.matches(pattern);
    }

}
```

此时方法中使用 `PhoneNumber phone`，语义更加清晰，在调用该方法时会进行强类型校验。

改造后的代码：

```java
public class User {
    Long userId;
    String name;
    PhoneNumber phone;
    Long repId;
}

public class RegistrationServiceImpl implements RegistrationService {

    private SalesRepRepository salesRepRepo;
    private UserRepository userRepo;

    public User register(String name, PhoneNumber phone) {
    
        // 获取手机号归属地编号和运营商编号，然后通过编号找到区域内的SalesRep
        String areaCode = getAreaCode(phone);
        String operatorCode = getOperatorCode(phone);
        SalesRep rep = salesRepRepo.findRep(areaCode, operatorCode);

        // 最后创建用户，落盘，然后返回
        User user = new User();
        user.name = name;
        user.phone = phone;

        if (rep != null) {
            user.repId = rep.repId;
        }

        return userRepo.save(user);
    }
    
    private String getAreaCode(PhoneNumber phone) {
        //...
    }
    
    private String getOperatorCode(PhoneNumber phone) {
       //...
    }
}
```

### 2.2核心业务逻辑清晰度

经过上一步的改造，代码优雅了一些，但是其功能不是很纯粹。该方法的功能是用户注册，所以它所承担的职责应该仅仅是注册，但是方法内包含了其他的业务逻辑，比如”获取手机号归属地编码“和”获取运营商编号“。

> 什么逻辑归属于哪个业务域，这就是对领域的理解，

”获取手机号归属地编码“和”获取运营商编号“不属于注册领域，应该属于 phoneNumber 领域，对代码再次优化

```java
public class PhoneNumber {

    private final String number;
    private final String pattern = "^0?[1-9]{2,3}-?\\d{8}$";
    
    public String getNumber() {
        return number;
    }

    // 仅存在含参构造器
    public PhoneNumber(String number) {
        if (number == null) {
            throw new ValidationException("number不能为空");
        } else if (isValid(number)) {
            throw new ValidationException("number格式错误");
        }
        this.number = number;
    }

    private boolean isValid(String number) {
        return number.matches(pattern);
    }
    
    public String getAreaCode() {
        //...
    }
    
    public String getOperatorCode(PhoneNumber phone) {
       //...
    }
}
```

此时 ，注册方法就变得很清晰了

```java
public class RegistrationServiceImpl implements RegistrationService {

    private SalesRepRepository salesRepRepo;
    private UserRepository userRepo;

    public User register(String name, PhoneNumber phone) {
    
        // 获取用户信息
        SalesRep rep = salesRepRepo.findRep(phone.getAreaCode(), phone.getOperatorCode());

        // 存储用户信息
        User user = new User();
        user.name = name;
        user.phone = phone;

        if (rep != null) {
            user.repId = rep.repId;
        }

        return userRepo.save(user);
    }
}
```

### 2.3 单元测试可行性

通过对 PhoneNumber 逻辑的内聚，对业务方法内逻辑的简化，写单元测试的效率能极大提高。而且 PhoneNumber 类型的改动频率比较小，一旦写了完善的测试用例，复用性会很高。

随着业务方法越来越多，业务方法内部的逻辑越来越复杂，单元测试的维护成本只会越来越低。

### 2.4 Domain Primitive

DP，Domain Primitive

在传统的 POJO 中，类中只包含属性和 getter/setter 方法。这里的 PhoneNumber 却包含了初始化、校验、属性处理等多种逻辑。这就是 DDD 和传统 MVC 开发的重要差异之一。

POJO 只包含属性和 getter/setter 方法，属于贫血模型；PhoneNumber 拥有属性和属性相关的职责，属于充血模型。

PhoneNumber 这种类型成为 DP，Domain Primitive。

在 DDD 中，DP 可以说是一切模型、方法、架构的基础。它在特定领域精准定义、可以自我验证、拥有行为的对象。可以认为是领域的最小组成部分。

DP 三条原则：

- 让隐性的概念显性化
  - 归属地编号、运营商编号就属于电话号码的隐形属性
- 让隐性的上下文显性化
  - 比如手机号所采用的协议
- 封装多对象行为
  - 一个 DP 可以封装其他多个 DP 的行为
