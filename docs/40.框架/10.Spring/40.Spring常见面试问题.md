---
title: Spring常见面试问题
date: 2022-07-16 00:15:51
permalink: /pages/604946/
categories:
  - 框架
  - Spring
tags:
  - 
author: 
  name: Marvel
  link: https://github.com/zouquchen
---
# Spring常见面试问题

::: warning 草稿



:::

## 1 什么是Spring框架

开源轻量级Java开发框架，Spring框架指的是Spring Framework，它是很多模块的集合，使用这些模块可以很方便的协助我们开发。

核心思想：不重新造轮子，开箱即用。

## 3 什么是bean？

简单来说，bean代指的就是那些被IoC容器所管理的对象。我们需要告诉IoC容器帮助我们管理哪些对象，这个是通过配置元数据来定义的。配置元数据可以是XML文件、注解或Java类。

```xml
<!-- Constructor-arg with 'value' attribute -->
<bean id="..." class="...">
   <constructor-arg value="..."/>
</bean>
```

## 4 bean的作用域有哪些？

- singleton：唯一bean实例，默认是单例的。
- prototype：每次请求都会创建一个新的bean实例。
- request：每次HTTP请求都会创建一个新的bean实例，该bean仅在当前HTTP request内有效。
- session：每一次来自新session的HTTP请求都会产生一个新的bean，该bean仅在当前HTTP session内有效。
- global-session：全局session作用域，

## 5 单例bean的线程安全了解吗？

单例bean存在线程安全问题，主要是因为当多个线程操作同一个对象的时候是存在资源竞争的。

解决办法：

1. 在bean中尽量避免定义可变的成员变量。
2. 在类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在ThreadLocal中。

不过，大部分bean实际都是无状态的（没有实例变量）的（比如dao、Service），这种情况下，bean线程是安全的。

## 6 @Component和@Bean的区别是什么？

1. @Component注解作用于类，而@Bean作用于方法。
2. @Component通常是通过类路径扫描来自动侦测及自动装配到Spring容器。（我们可以使用@ComponentScan注解定义要扫描的路径从中找出表示了需要装配的类自动装配到Spring的bean容器中）。@Bean注解通常是我们在标有该注解的方法中定义产生整个bean，@Bean告诉了Spring这是某个类的实例，当我们需要用它的时候还给我。
3. @Bean注解比@Component注解的自定义性更强，而且很多地方我们只能通过@Bean注解来注册bean。比如当我们引用第三方库中的类需要装配到Spring容器时，则只能通过@Bean来实现。

## 7 将一个类声明为bean的注解有哪些？

一般使用@Autowired注解自动装配bean，要想把类表示成可用于@Autowired注解自动装配的bean的类，需用一下注解：

- @Component：通用的注解，可标注任意类为Spring组件。如果一个Bean不知道属于哪个层，可以使用@Component注解标注。
- @Repository：对应持久层的Dao层，数据库相关操作。
- @Service：对应服务层，主要设计一些复杂的逻辑，需要用到Dao层。
- @Controller：对应Spring MVC控制层，接受用户请求并调用Service层返回数据给前端。

## 8 Bean的生命周期

> Spring里面的一切都是bean，存储在Spring容器中。

可以分为5各阶段：

创建前准备：从上下文和一些配置中查找并解析一些Bean有关的扩展实现，如init-method、destroy-method以及BeanFactoryPostProcessor，通过这些我们可以实现bean在加载过程中的一些扩展。

创建实例：通过反射去创建Bean的实例对象，并且扫描和解析Bean的一些属性。

依赖注入：如果被实例化的Bean存在依赖其他Bean对象的情况（@Autowired），则需要对这些依赖的Bean进行对象注入。执行扩展调用，比如BeanPostProcessors的before方法，InitializingBean的afterPropertieSet()方法。

容器缓存：把bean保存到容器中和Spring的缓存中，到这个阶段bean就可以被开发者使用了。这个阶段涉及到操作，如init-method以及BeanPostProcessors的after方法。

销毁实例：如果实现了DisposibleBean的destory()方法，或配置了destory-method方法，会在这个阶段被调用。

## 8 说一说对Spring容器的了解？

主要包含两种类型的容器：BeanFactory和ApplicationContext

- BeanFactory：基础的IoC容器，默认采用延迟初始化策略。只有当客户端对象需要访问容器中的某个受管理对象啊的时候，才对该受管对象进行初始化以及依赖注入的操作。所以，相对来说，容器启动初期速度较快，所需要的资源有限。对于资源有限，且功能要求不是很严格的场景，BeanFactory是比较合适的IoC选择。
- ApplicationContext：在BeanFactory基础上构建，ApplicationText所管理的对象，在该类型容器启动之后，默认全部初始化并绑定完成。所以，相对于BeanFactory来说，ApplicationContext要求更多的系统资源，启动时间会慢一些。在那些系统资源充足，并且要求更多的功能的场景中，ApplicationContext类型的容器是比较合适的选择。

## 9 说说对BeanFactory的了解？

BeanFactory是类的通用工程，它可以创建并管理各种类的对象。Spring称这些被创建和管理的Java对象为Bean。

## 8 Spring中的设计模式——单例模式

在系统中，有一些对象其实我们只需要一个，比如：线程池、缓冲池、日志对象、驱动等对象。事实上，这一类对象只能有一个实例，如果制造出多个实例就可能会导致一些问题的产生，比如：程序行为异常、资源使用过量、不一致的结果。

使用单例的好处：

- 对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔开销；
- 由于new操作的次数减少，因而对系统内存的使用率也会降低，减轻GC压力，缩短GC停顿时间。

## 7 Spring事务的传播机制？

- propagation_required：如果外部没有事务，就开启一个事务；如果外部存在一个事务，就加入到该事务中。适用于增删改。（常用）
- propagation_supports：如果外部事务不存在，则不使用事务；如果外部存在一个事务，就加入到该事务中。适用于查询方法。（常用）
- propagation_mandatory：如果外部事务不存在，抛出异常；如果外部存在一个事务，就加入到该事务中。
- propagation_required_new：如果外部没有事务，就开启一个事务；如果外部存在一个事务，挂起外部事物，创建新的事物。
- propagation_not_supported：如果外部没有事务，不开启事务；如果外部存在一个事务，挂起外部事物。
- propagation_never：如果外部事务不存在，则不使用事务；如果外部存在一个事务，则抛出异常。
- propagation_nested：嵌套事务，如果当前事务存在，则嵌套在事务中执行。如果当前事务不存在，则创建一个新事物。如果嵌套事务发送回滚，只回滚嵌套部分的事务。

## @Autowired与@Resource的区别

1. @Autowired是Spring提供的注解，@Resource是JDK提供的注解。
2. @Autowired只能按类型注入，Spring会自动在代码中找到与其类型匹配的Bean进行注入，如果存在多个Bean时需要使用@Qualifier指明Bean的名称；@Resource默认按名称注入，也支持按类型注入。
3. @Autowired按类型装配依赖对象，默认情况它要求依赖对象必须存在，如果允许null值，可以设置它required属性为false，如果想要使用按名称装配。可以结合@Qualifier注解一起使用。@Resouce有两个重要的属性：name和type。name属性指定byName，如果没有指定name属性，当注解标注在属性的setter方法上，即默认取字段的名称作为bean名称寻找依赖对象。需要注意的是，@Resouce如果没有指定name属性，并且按照默认的名称仍然找不到依赖对象时，@Resource注解会回退到按类型装配。但一旦指定了name属性，就只能按名称装配了。

## 1 什么是循环依赖问题？

```java
// A 依赖于 B
public class A {
	@Autowird
	private B b;
}
// B 依赖于 A
public class B {
	@Autowird
	private A a;
}
```

<img src="https://studynote-images.oss-cn-hangzhou.aliyuncs.com/beans-dependency.png" alt="beans-dependency" style="zoom:50%;" />

官网解释：https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-dependency-resolution

依赖的注入方式：构造方法注入（无法解决循环依赖）、Set注入（能够解决循环依赖）

默认的单例（singleton）的场景支持循环依赖；原型（Prototype）的场景不支持循环依赖，会报错。

Spring内部通过三级缓存来解决循环依赖问题，DefaultSingletonBeanRegistry。

## 2 三级缓存解决循环依赖问题？

**关键词**：三级缓存、提前暴露对象

只有单例的 Bean 会通过三级缓存提前暴露来解决循环依赖的问题，而非单例的 bean，每次从容器中获取都是一个新的对象，都会重新创建，所以非单例的bean是没有缓存的，不会将其放到三级缓存中。

实例化：内存中申请一块内存空间；初始化：属性填充

```java
public class DefaultSingletonBeanRegistry extends SimpleAliasRegistry implements SingletonBeanRegistry { 
    /** Cache of singleton objects: bean name to bean instance. */
    private final Map<String, Object> singletonObjects = new ConcurrentHashMap<>(256); // 一级缓存，单例池

    /** Cache of singleton factories: bean name to ObjectFactory. */
    private final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<>(16); // 三级缓存

    /** Cache of early singleton objects: bean name to bean instance. */
    private final Map<String, Object> earlySingletonObjects = new HashMap<>(16);  // 二级缓存
    
    ...
}
```

⭐ **第一级缓存**：singletonObjects，单例池

存放已经经历了完整生命周期的 Bean对象

⭐ **第二级缓存**：earlySingletonObjects，早期单例对象的高速缓存

表示 Bean 的生命周期还没走完（Bean 的属性还未填充）就把这 个Bean 存入该缓存中，也就是实例化但未初始化的 Bean 放入该缓存里。同时也保证了单例，不会重复创建。

⭐ **第三级缓存**：Map<String, ObjectFactory<?>> singletonFactories，单例工厂的高速缓存

存放可以生成 Bean 的工厂。假如 A 类实现了FactoryBean，那么依赖注入的时候不是 A 类，而是 A 类产生的 Bean。

**简单过程**

1. A 创建过程需要 B，于是A将自己放到三级缓存里面，去实例化 B

2. B 实例化的时候发现需要 A，于是 B 先查一级缓存，没有，再查二级缓存，没有，再查三级缓存，找到了 A（执行 Lamda 表达式），然后把三级缓存里面的 A 移动二级缓存里。
3. B 初始化完毕，将自己放到一级缓存（此时 B 里面的 A 依然是创建中状态）。
4. 继续创建 A，此时 B 已经创建结束，直接从一级缓存里面拿到 B，完成创建，并将 A 放到一级缓存中。

![三级缓存解决循环依赖](https://studynote-images.oss-cn-hangzhou.aliyuncs.com/3-map-bean-dependency.png)

Debug：创建过程的六个关键方法：getBean、doGetBean、createBean、doCreateBean、createBeanInstance、populateBean



**一级缓存能否解决循环依赖**？

不可以的，因为创建一般的对象没有容器进行存储。

**二级缓存能否解决循环依赖**？

可以，但是有条件。条件就是不使用 AOP 进行后置增强处理。此时完整对象就存储在一级缓存中，非完整对象存储在二级缓存中。

**解决循环依赖的关键**？

三级缓存，用于存放创建 Bean 对象的 Lambda表示。某一个 Bean 会不会出现循环依赖一开始是不知道的，所以干脆一开始就将 beanName、beanDefination、bean 生成一个 Lambda表达式存放到三级缓存中，当出现循环依赖的时候直接将 Lambda 表达式拿出来执行。这个 Lambda 表达式来判断要不要进行 AOP 等等。

## ApplicationContext 与 BeanFacatory 区别

ApplicationContext 继承 BeanFactory

![image-20220825103526220](https://studynote-images.oss-cn-hangzhou.aliyuncs.com/BeanFactory&ApplicationContext.png)

BeanFactory 是 Spring 中非常核心的组件，表示 Bean 工厂，可以生成 Bean，维护 Bean，而 ApplicationContext 继承了 BeanFactory，所以 ApplicationContext 拥有 BeanFactory 所有的特点，也是一个 Bean 工厂，但是 ApplicationContext 除继承了 BeanFactory 外，还继承了诸如EnvironmentCapable、MessageSource、ApplicationEventPublisher 等接口，从而 ApplicationContext 还要获取系统环境变量、国际化、事件发表等功能，这是 BeanFactory 所不具备的。

## Spring 如何创建一个 Bean 对象的？

通过 `new UserService()` 创建的对象和 Spring 容器帮我们创建的 Bean 对象是不一样的，少了依赖注入、属性填充等步骤。依赖注入，指需要给加了 @Autowire 或 @Resource 注解的对象注入到对象中。

也就是说，Spring 在创建 Bean 对象后，再去看看这个对象内部需要哪些对象，并创建内部依赖的对象，并把依赖的对象注入进去。

容器底层就是一个 Map，Key 为 BeanName，Value 为 Bean 对象。单例 Bean 是放在一个单例池中。

依赖注入后，执行初始化前的任务、初始化过程（实现 InitializingBean 接口，实现 afterPropertiesSet 方法）、舒适化后的任务



Bean 实例化：通过构造器得到一个对象

Bean 初始化：对已经实例化的对象，执行初始化方法（自定义的方法）



UserService 类 ---> 推断无参构造器 ---> 对象 ---> 依赖注入 ---> 初始化（@PostConstruct）---> 初始化（InitializingBean）---> 初始化后（AOP）--->  代理对象 ---> 放入单例池 ---> Bean 对象



推断构造方法：Spring 根据类已有的构造方法进行选择，如果有 @Autowired 指定的就用指定的，如果没指定则用无参构造方法。如果有多个有参构造方法，且没有无参构造方法则会报错。当选择好构造方法后，如果构造方法有入参，则会从容器中获取，获取方式先ByType 再 ByName

依赖注入：当对象实例化完成，Spring 会看对象内哪些属性加了 @Autowired 注解，对其进行赋值，先 ByTpe 再 ByName。



当使用 AOP 后，单例池中存放的是代理对象，注意，代理对象后面没有依赖注入了。

OrderService 是一个单例 Bean，那么在 Spring 容器中只能有一个 OrderService 类型的 Bean。这是错的。



当使用 AOP 对被代理类进行增强时生成了代理类对象 UserServiceProxy。普通对象 UserService 里面包含对象 OrderService，Spring 容器会自动将 OrderService 注入到 UserService 内。但 UserServiceProxy 对象内部的 OrderService = null，因为前面说过了，AOP 之后不会再依赖注入了，但使用 UserServiceProxy 的时候依然能够使用 OrderService 里面的方法，因为 UserServiceProxy 里面包含了被代理对象 UserService，而 UserService 对象内部已经注入了 OrderService。代理类增强代理类的方法：

```java
public void test() {
	// 前面方法1
	target.test(); // 执行被代理类的方法
	// 切面方法2
}
```

## @Transactional 注解执行的流程

1. 事务管理器新建一个数据库连接 conn，保证方法内的所有操作都使用同一个数据库连接。
2. 关闭自动提交：conn.autoCommit = false
3. 获取第一步事务管理器创建的链接（是一个 ThreadLocal 对象，如果获取不到的话就自己创建，那么事务就失效了），执行一系列方法 sql
4. 未抛异常，conn.commit()
5. 抛出异常，conn.rollback()

## Spring 事务什么时候会失效？

Spring事务的原理是 AOP，进行切面增强，那么事务失效的根本原因是 AOP 失效，常见的情况有：

1. 方法不是 public 的，@Transactional 只能用于 public 方法上，否则事务不会失效，如果要用在非 public 方法上，可以开启 AspectJ 代理模式
2. 数据库不支持事务
3. 没有被 Spring 管理
4. 异常被吃掉，事务不会回滚（或者抛出的异常没有被定义，默认为 RuntimeException）
5. 方法互相调用时注解失效，需要分析是普通方法还是代理方法的调用，只要代理对象调用其他方法时注解才会生效。

下面详细解释一下第五点，以下面这行代码为案例

```java
Class UserService {
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    @Transactional
    public void test() {
        jdbcTemplate.excute("xxxxx1");
        a();
    }

    @Transactional(propagation = Propagation.NEVER)
    public void a() {
        jdbcTemplate.excute("xxxxx2");
    }
}
```

`test()` 方法开启事务，执行 sql 语句，再调用 `a()` 方法，该方法也在这个事务当中。需要注意的是，`a()` 方法也开启了事务，并设置传播机制为 NEVER，表示如果外部事务不存在，则不使用事务；如果外部存在一个事务，则抛出异常。

错误理解：因为带事务的方法 test() 调用方法 a()，由于 `a()` 的传播机制为 NEVER，所以会抛出异常。

正确理解：首先我们要知道，Spring 内部执行的增强的 `test()` 方法其实是调用被代理对象的 `test()`，被代理对象 `test()` 方法调用的 `a()` 方法是普通的方法，是没有经过 AOP 增强的方法，不存在事务，不会抛出异常。

```
// 模拟代理类
public void test() {
	// 事务管理器新建一个数据库连接
	// conn.autocommit = false
	// target.test(); // 普通对象.test()
	// conn.commit() 或者 conn.rollback()
}
```

那么如何修改呢？

方法1：把两个方法分到两个文件，通过 @Autowired 注入再调用，此时 `test()` 方法调用的 `a()` 方法就是动态代理生成的方法。

方法2：自己注入自己，通过 @Autowired 注入自己 UserService，调用 `userservice.a()`

## 什么是 Bean 的自动装配，有哪些方式？

开启自动装配，只需要在 xml 配置文件中定义 autowire 属性，或者使用 @Autowired 注解



## Spring 中 Bean 创建的生命周期有哪些步骤？

Spring 中一个 Bean 的创建大概分为以下几个步骤：

1. 推断构造方法：使用哪个构造器
2. 实例化
3. 填充属性，也就是依赖注入
4. 处理 Aware 回调
5. 初始化前，（比如，执行带有 @PostConstruct 注解的方法）
6. 初始化，处理 InitalizingBean 接口
7. 初始化后，进行 AOP

![image-20220820213610149](https://studynote-images.oss-cn-hangzhou.aliyuncs.com/Bean-life-cycle.png)



## Spring 中 Bean 是线程安全的吗

Spring 本身没有针对 Bean 做线程安全处理，所以：

1. 如果 Bean 是无状态的，那么 Bean 则是线程安全的
2. 如果 Bean 是有状态，那么 Bean 则不是线程安全的

另外，Bean 是不是线程安全，跟 Bean 的作用域没有关系，Bean 的作用域只是表示 Bean 的生命周期范围，对于任何生命周期的 Bean 都是一个对象，这个对象是不是线程安全的，还是得看这个 Bean 对象本身。

## Spring Boot、SpringMVC 和 Spring 的区别？

Spring：是一个 IOC 容器，用来创建、管理 Bean 对象，使用依赖注入实现控制反转，可以方便的整合框架；同时，提供给 AOP 弥补 OOP 代码重复问题，可以将不同类不同方法中的公共处理抽取成切面，使用 AOP 对已有代码进行增强。如，日志统计、异常处理、事务等。

SpringMVC：是 Spring 对 Web 框架的一个解决方案，提供了一个总的前端控制器 Servlet，用来接收请求，然后定义了一套路由策略（url 到 handle 的映射）及适配执行 handle，将 handle 结果使用视图解析技术生成视图返回给前端。

SpringBoot：是 Spring 提供一个快速开发工具包，能让程序员更方便、更快速的开发基于 Spring + SpringMVC 应用，简化了配置，整合了一系列的解决方案（starter 机制）。



## @Configuration 注解的作用？
