---
title: Spring三级缓存解决循环依赖
date: 2022-08-25 14:44:07
permalink: /pages/93a802/
categories:
  - 框架
  - Spring
tags:
  - 
author: 
  name: Marvel
  link: https://github.com/zouquchen
---
# Spring 循环依赖解决三级缓存

## 1. 循环依赖

什么是循环依赖？

```java
// A 依赖于 B
public class A {
	@Autowird
	private B b;
}
// B 依赖于 A
public class B {
	@Autowird
	private A a;
}
```

<img src="https://studynote-images.oss-cn-hangzhou.aliyuncs.com/beans-dependency.png" alt="beans-dependency" style="zoom:50%;" />

[循环依赖官方解释](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-dependency-resolution)：

> Circular dependencies
>
> If you use predominantly constructor injection, it is possible to create an unresolvable circular dependency scenario.
>
> For example: Class A requires an instance of class B through constructor injection, and class B requires an instance of class A through constructor injection. If you configure beans for classes A and B to be injected into each other, the Spring IoC container detects this circular reference at runtime, and throws a `BeanCurrentlyInCreationException`.
>
> One possible solution is to edit the source code of some classes to be configured by setters rather than constructors. Alternatively, avoid constructor injection and use setter injection only. In other words, although it is not recommended, you can configure circular dependencies with setter injection.
>
> Unlike the typical case (with no circular dependencies), a circular dependency between bean A and bean B forces one of the beans to be injected into the other prior to being fully initialized itself (a classic chicken-and-egg scenario).

依赖的注入方式

- 构造方法注入（无法解决循环依赖）
- Set注入（能够解决循环依赖）

默认的单例（singleton）的场景支持循环依赖；原型（Prototype）的场景不支持循环依赖，会报错。

## 2. 前置知识

> 暂时先简单描述一下，之后再好好研究并完善。

需要了解 Bean 的创建流程：

1. 推断选择构造器
2. 实例化对象
3. 填充属性，也就是依赖注入
4. 初始化前（如，执行带有 @PostConstruct 注解的方法）
5. 初始化（如，处理 InitializingBean 接口）
6. 初始化后（AOP 增强）
7. 代理对象放入单例池

需要区分实例化和初始化的区别：

- 实例化：通过构造器得到一个对象，里面的属性值为 null

- 初始化：对已经实例化的对象，执行初始化方法（自定义的方法）

## 3. 三级缓存解决循环依赖

### 3.1 三级缓存

```java
public class DefaultSingletonBeanRegistry extends SimpleAliasRegistry implements SingletonBeanRegistry { 
    /** Cache of singleton objects: bean name to bean instance. */
    private final Map<String, Object> singletonObjects = new ConcurrentHashMap<>(256); // 一级缓存，单例池

    /** Cache of singleton factories: bean name to ObjectFactory. */
    private final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<>(16); // 三级缓存

    /** Cache of early singleton objects: bean name to bean instance. */
    private final Map<String, Object> earlySingletonObjects = new HashMap<>(16);  // 二级缓存
    
    ...
}
```

⭐ **第一级缓存**：singletonObjects，**存放完成品对象**

单例池，存放已经经历了完整生命周期的 Bean对象

⭐ **第二级缓存**：earlySingletonObjects，**存放半成品对象**

早期单例对象的高速缓存，表示 Bean 的生命周期还没走完（Bean 的属性还未填充）就把这 个Bean 存入该缓存中，也就是实例化但未初始化的 Bean 放入该缓存里。同时也保证了单例，不会重复创建。

⭐ **第三级缓存**：Map<String, ObjectFactory<?>> singletonFactories，**存放 lambda 表达式**

单例工厂的高速缓存，存放可以生成 Bean 的工厂。假如 A 类实现了FactoryBean，那么依赖注入的时候不是 A 类，而是 A 类产生的 Bean。

### 3.2 二级缓存解决循环依赖

只使用两级缓存能否解决循环依赖呢？其实是可以的，但是要保证对象没有经过 AOP 增强，下面来说说原理。

我们来重新看一下循环依赖的问题：

![1.循环依赖](https://studynote-images.oss-cn-hangzhou.aliyuncs.com/circle-dependeny1.png)

步骤如下：

1. 创建 A 对象
2. 实例化 A 对象，此时 b=null
3. 给 A 对象的 b 属性赋值，也就是依赖注入
4. 判断 B 对象是否存在，此时 B 对象不存在
5. 创建 B 对象
6. 实例化 B 对象，此时 a=null
7. 给 B 对象的 a 属性赋值，也就是依赖注入
8. 判断 A 对象是否存在，此时 B 对象不存在
9. 重复步骤 1 - 9

想要打破循环依赖问题，可以在步骤 9 的地方打破循环。

此时可以引入两个缓存（Map），一级缓存 singletonObjects 存储完整对象，二级缓存 earlySingletonObjects 存储半成品对象。

![2.打破循环依赖](https://studynote-images.oss-cn-hangzhou.aliyuncs.com/circle-dependency2.png)

步骤如下：

1. 创建 A 对象
2. 实例化 A 对象，此时 b=null
3. 将半成品 A 对象放入二级缓存
4. 给 A 对象的 b 属性赋值
5. 判断一级缓存和二级缓存中是否有 B 对象，此时没有
6. 创建 B 对象
7. 实例化 B 对象，此时 a=null
8. 将半成品 B 对象放入二级缓存
9. 给 B 对象的 a 属性赋值
10. 判断一级缓存中是否有 A 对象，没有
11. 判断二级缓存中是否有 A 对象，有
12. 将二级缓存中的 A 对象赋值给 B 对象的 a 属性
13. 此时 B 对象完成了创建，将其从二级缓存移到一级缓存
14. 回到步骤 4，给 A 对象的 b 属性赋值
15. 判断一级缓存中是否有 B 对象，有
16. 将一级缓存中的 B 对象赋值给 A 对象的 b 属性
17. 此时 A 对象完成了创建，将其从二级缓存移到一级缓存

这里为什么要使用两个缓存呢，因为要保证只有经历了完整生命周期的 Bean 对象才放入单例池（一级缓存）中，如果半成品对象也放入单例池中，可能会从单例池中取出半成品的 Bean 对象导致出错。所以，成品对象和半成品对象分开放。

### 3.3 三级缓存解决循环依赖

假设，A 和 B 都进行了 AOP，此时在进行上面的步骤：

![二级缓存解决循环依赖AOP问题](https://studynote-images.oss-cn-hangzhou.aliyuncs.com/circle-dependency4.png)

经过上面的操作后，我们可以发现：

- 代理 A 对象中包含代理 B 对象，正确
- 代理 B 对象中包含普通 A 对象，错误，也就是说 B 对象中没有将最终的代理 A 对象注入进去，而是在之前注入了一个普通对象。

出现这个问题的原因是：当循环依赖出现时，未经历 AOP 的对象就被注入到了其他 Bean 对象中。

解决方案：当循环依赖出现时，将被注入的对象提前进行 AOP 增强

```
实例化 A —— 半成品 A —— 依赖注入 —— B 不存在

实例化 B —— 半成品 B —— 依赖注入 —— 发现循环依赖 —— 对 A 对象进行增强 —— A 的代理对象 —— 半成品 B（含有 A 的代理对象） —— 初始化前 —— 初始化 —— 初始化后（AOP）—— 成品 代理对象 B（含有 A 的代理对象）—— 单例池

A 继续依赖注入 —— 成品 A（含有 B 代理对象）—— 初始化前 —— 初始化 —— 初始化后（AOP） —— 代理对象 A（含有代理 B 对象）—— 放入单例池
```

Spring 不知道在创建 Bean 的过程中，是否会出现循环依赖，是否会进行 AOP，所以将创建 Bean 的过程写成一个 lambda 表达式放入三级缓存当中。

**详细流程**

1. 开始创建 A 对象
2. 实例化 A 对象
3. 将 lambda 表达式写入三级缓存中
4. 为 A 对象填充属性
5. 扫描发现 A 对象依赖 B 对象，此时容器中没有 B 对象
6. 开始创建 B 对象
7. 实例化 B 对象
8. 将 lambda 表达式写入三级缓存中
9. 为 B 对象填充属性
10. 扫描发现 B 对象依赖 A 对象，判断容器中是否有 A 对象
11. 分别判断一级、二级、三级缓存中是否有 A 对象，在三级缓存中有 A 的 lambda 表达式
12. 执行 lambda 表达式，如果有 AOP 增强就返回 A 的代理对象，否则就返回 A 的原始对象
13. 将 A 从三级缓存移动到二级缓存
14. 给 B 对象中的 a 属性进行赋值，把 A 对象注入进去，此时 B 已经完成了创建
15. 将 B 对象放到一级缓存，删除二级和三级缓存中的 B 对象。
16. 给 A 对象中的 b  属性进行赋值，把 B 对象注入进去，此时 A 已经完成了创建
17. 将 A 对象放到一级缓存，删除二级和三级缓冲中的 A 对象。

![三级缓存解决循环依赖](https://studynote-images.oss-cn-hangzhou.aliyuncs.com/3-map-bean-dependency.png)

**简单过程**

1. A 创建过程需要 B，于是A将自己放到三级缓存里面，去实例化 B

2. B 实例化的时候发现需要 A，于是 B 先查一级缓存，没有，再查二级缓存，没有，再查三级缓存，找到了 A（执行 Lamda 表达式），然后把三级缓存里面的 A 移动二级缓存里。
3. B 初始化完毕，将自己放到一级缓存（此时 B 里面的 A 依然是创建中状态）。
4. 继续创建 A，此时 B 已经创建结束，直接从一级缓存里面拿到 B，完成创建，并将 A 放到一级缓存中。

## 4. 源码测试

::: 编辑中

:::

### 4.1 环境搭建

配置 Spring 的环境，创建以下内容：

A 类里面包含 B 类

```java
public class A {
    private B b;

    public B getB() {
        return b;
    }

    public void setB(B b) {
        this.b = b;
    }
}
```

B 类里面包含 A 类

```java
public class B {
    private A a;

    public A getA() {
        return a;
    }

    public void setA(A a) {
        this.a = a;
    }
}
```

注解配置，创建 a 和 b 两个 bean 对象，并为他们注入属性。

```xml
<bean class="com.zqc.domain.A" id="a">
    <property name="b" ref="b"/>
</bean>
<bean class="com.zqc.domain.B" id="b">
    <property name="a" ref="a" />
</bean>
```

启动类，通过注解创建 Spring 容器。

```java
public class SpringDemo {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
        A bean = context.getBean(A.class);
        System.out.println(bean);
    }
}
```

### 4.2 源码

Debug：创建过程的六个关键方法：getBean、doGetBean、createBean、doCreateBean、createBeanInstance、populateBean



ObjectFactory 是函数式接口，有且仅有一个方法，可以当作方法的参数传递进去，当指明此类型参数的方法，可以传入一个 lambda 表达式，在执行此行代码的时候并不会执行 lambda 表达式，而是在调用 getObject 方法时才会执行 lambda 表达式的处理逻辑。
