---
title: HashMap常见知识点
date: 2022-07-13 16:28:42
permalink: /pages/56deae/
categories:
  - Java
  - Java容器
tags:
  - 
author: 
  name: Marvel
  link: https://github.com/zouquchen
---
# HashMap常见知识点

## hashMap的hash算法实现原理（扰动函数）？

hashMap的hash算法是为了使散列表分布的更加均匀。

```java
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

获取元素的索引为(length - 1) & hash，由于length不会很长，这样就会导致高位的hash值用不上，不同的hashcode在hashmap中可能会得到相同的位置索引（hashcode()是计算对象的hash值，hash()是hashmap中对原对象hash值的重新计算，计算之后减少哈希冲突）。所以把高16位的hashcode与低16位异或，此时高16位不变，低16位会发生改变。

在使用hashmap的get方法时，会通过`tab[(n - 1) & hash])`获取元素的索引。

> length = 2 ^ n，默认大小length = 2 ^ 4 = 16，length - 1 = 15 = 11111

## 介绍一下HashMap的实现原理？

有一个Entry数组，Entry里面包含key和value。当要添加一组键值对的时候，会根据hash算法算出key所对应的hash值，通过数组大小n-1 & hash值后，得到一个数组的下标，最后把Entry放到这个位置。

因为，hash算法可能会产生冲突，且数组大小是有限的，所以很可能通过不同的key计算得到一样的下标，为了解决Entry存放冲突的问题，采用链表法实现，在该位置引出一个链表，用于存储冲突的Entry。

在jdk1.7之前，链表法采用的是头插法，即在链表头处插入新的Entry；在jdk1.8之后，采用尾插法，并且引入红黑树。当链表长度大于8且数组长度大于等于64时，把链表转化为红黑树，当红黑树节点小于6时，又会退化为链表。

## 为什么JDK1.8要对HashMap做红黑树这个改动？

主要是为了避免hash冲突导致链表过长，这样get的时间复杂度就不是O(1)了，因为可能需要遍历链表来查找Entry。

## 为什么定义链表长度为8且数组大小大于等于64才转红黑树？不要链表直接用红黑树不行吗？

因在HashMap的注释中写道：

```java
* Because TreeNodes are about twice the size of regular nodes,
```

因为红黑树节点的大小是普通节点大小的两倍，所以为了节省内存空间不会直接使用红黑树，只有达到一定数量才会转成红黑树，这里定义的是8.

为什么是8呢，HashMap的注释中有写到：

<img src="https://raw.githubusercontent.com/zouquchen/Images/main/imgs/concurrentHashMap.png" alt="image-20220306185832957" style="zoom: 67%;" />

和泊松分布有关，在阈值为0.75的情况下，理论冲突节点长度为8的概率为0.00000006，小于千万分之一，是非常小的概率。

这就是基于时间和空间的平衡，红黑树占用内存大，所以节点少的时候就不用红黑树，如果万一真的冲突很多，就用红黑树，选择参数为8的大小，就是为了平很时间和空间问题。

## 为什么节点小于6要从红黑树转成链表？

同样是为了平衡时间和空间，节点太少链表遍历也很快，没必要使用红黑树，变成链表节约内存。为什么是6而不是8呢？因为要六个缓存余地，避免反复横跳。

## HashMap源码底层结构分析？

HashMap底层：数组 + 链表 +红黑树

通过使用链表和红黑树来解决哈希冲突，链表长度大于阈值（默认位8）时，会调用`treeifyBin()`来决定时扩充数组还是将链表转换为红黑树。只有当数组长度大于64情况下，才会执行转换红黑树操作，否则执行`resize()`来扩充数组。

**loadFactor负载因子**

控制数组疏密程度，loadFactor越趋近于1，数组中存放的数据越多，链表越长，越趋近于0，数组中存放的数据越少。loadfactor太大导致查找元素效率低，太小会导致数组利用率低。

**threshold扩容阈值**

threshold = capacity * loadFactor，当size >= threshold就对数组进行扩容。

loadFactor的默认值位0.75，数组的默认容量位16，所以当数据量达到`16*0.75=12`时就会扩容。

## HashMap为什么线程不安全？举例说明。

JDK1.7中，当并发执行扩容操作时容易形成环链造成死循环

JDK1.8中，当并发执行put操作时会发送数据覆盖的情况。

https://blog.csdn.net/zzu_seu/article/details/106669757

## HashMap的put和get方法？

**put方法**

put方法中调用putVal方法，putVal并不提供给用户使用。

**putVal方法**

1. 判断数组是否为空或者长度为0，如果是就要resize扩容。
2. 根据hash计算数组下标，如果定位到数组位置没有元素，直接插入。
3. 如果定位到数组位置有元素，就要和插入的key比较，如果key相同就直接覆盖。
4. 如果key不同，就判断p是否是一个树节点，若是树节点，就调用将元素添加进入树节点；如果不是树节点，就遍历链表插入链表尾部。
5. 如果链表长度大于8，且数组长度小于64，需要对数组进行扩容；如果链表长度大于8，数组长度不小于64，需要将链表转化为红黑树。
6. 如果元素个数大于扩容阈值threshold，需要对数组进行扩容。

![ ](https://raw.githubusercontent.com/zouquchen/Images/main/imgs/put%E6%96%B9%E6%B3%95.png)

**get方法**

get方法会调用getNode方法。

**getNode方法**

根据hash值和key获取节点信息，如果找不到对象则返回null。

## HashMap扩容原理？

默认容量16，默认加载因子0.75，当HashMap中元素超过容量*加载因子时会进行扩容。

## ConcurrentHashMap结构

jdk1.7：由多个Segment组成，一个Segment就类似于一个HashMap的结构，每一个Segment可以扩容，但Segment的个数一旦初始化就不能改变，默认Segment时16个，所以可以认为ConcurrentHashMap默认支持16个线程并发。

<img src="https://raw.githubusercontent.com/zouquchen/Images/main/imgs/hashmap%E6%B3%A8%E9%87%8A.png" alt="image-20220302163940416" style="zoom: 50%;" />

Jdk1.8：使用Synchronized锁加CAS机制，结构从Segment数组+HashEntry数组+链表进化成了Node数组+链表/红黑树，Node是类似于一个HashEntry的结构，他的冲突达到一定大小时会转化成红黑树，冲突小于一定数量时会退回链表。

## HashMap与ConcurrentHashMap在JDK1.7和JDK1.8的区别？

HashMap：

- JDK1.7之前，基于数组和链表实现的，链表采用头插法。
- JDK1.8之后，在解决Hash冲突的时候有了较大的变化，当链表长度大于阈值（默认为8）时将链表转化为红黑树，以减少搜索时间，链表采用尾插法。将链表转化为红黑树前会判断，如果当前数组长度小于64，那么会选择先扩容，而不是转换为红黑树。

ConcurrentHashMap:

- JDK1.7之前，基于分段数组和链表实现的，使用分段锁segment，每一把锁只锁容器中一部分数据，多线程访问容器里不同数据段的数据就不会存在锁竞争的情况，提高并发访问效率。
- JDK1.8之后，摒弃Segemtn概念，直接使用Node数组+链表/红黑树，并发控制使用synchronized和CAS来操作。synchronized只锁定当前链表或红黑树的首节点。

## 为什么 HashMap 的 size 为 2 的冥次方？

- 为了使 hash 表中的**数分布更均匀**，某个数在 hash 数组中的位置计算公式为hash(key) & (len-1)，此时当(len-1)为 1111，即 len 为 2 的幂次方大小时分布之最均匀，故采用两倍扩容的方式。

- 当 length 总是 2 的 n 次方时,h& (length-1)运算等价于对 length 取模,也就是 h%length,但是&比%具有更高的效率。
- 当数组长度为 2 的 n 次幂的时候,不同的 key 算得的 index 相同的几率较小,那么 数据在数组上分布就比较均匀,也就是说碰撞的几率小,相对的,查询的时候就不用遍历某个位置上的链表,这样查询效率也就较高了。

## HashCode介绍？

hashCode()作用是获取哈希码（散列码），返回是int，哈希码的作用是确定该对象在哈希表中的索引位置。hashCode()是Object中的方法，是本地方法，也就是用c/c++实现的，通常是用来将对象的内存地址转换为整数之后返回。

```java
public native int hashCode()
```

散列表存储的是键值对（key-value）：能根据键快速检索出对应的值。

## 为什么要有hashCode？

以HashSet为例，当把对象加入HashSet时，首先计算对象的hashCode值来判断对象加入的位置，同时会与其他已经加入的对象的hashCode作比较，如果没有相符合的hashCode，hashSet会假设这个对象没有出现过；如果发现有相同hashcode值的对象，会调用equals()方法来检查对象是否真的相等，如果相同，hashset就不让其加入。如果不同，就会重新散列到其他位置。这样就大大减少equals的次数，提高执行效率。

## 为什么要重写equals时必须重写hashCode方法？

如果两个对象相等，那么hashCode一定相同。两个对象具有相同的hashcode值，他们却不一定相等。因此，equals方法被覆盖了，hashCode方法也要重写，以确保相同的对象有相同的hashcode。