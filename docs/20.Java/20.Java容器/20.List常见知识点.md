---
title: List常见知识点
date: 2022-07-13 16:28:42
permalink: /pages/db1d18/
categories:
  - Java
  - Java容器
tags:
  - 
author: 
  name: Marvel
  link: https://github.com/zouquchen
---
# List常见知识点

## ArrayList和Vector的区别？

- ArrayList是List的主要实现类，底层使用Object[]存储，适合于频繁的查找工作，线程不安全，效率高。
- Vector是List的古老实现类，地城使用Object[]存储，线程安全，效率低。

## ArrayList和LinkedList区别?

- 线程安全：都是线程不安全的。
- 底层数据结构：ArrayList使用的是Object数组；LinkedList使用的是双向链表
- 插入和删除：ArrayList插入和删除慢，LinkedList插入和删除快。
- 随机访问：ArrayList支持随机访问，LInkedList不支持
- 内存占用：LinkedLisst占用空间多余ArrayList

## Vector和CopyOnWriteArrayList区别？

- 都是线程安全的，底层实现都是数组。
- Vector的每个方法都进行了加速。
- CopyOnWriteArrayList的读操作不加锁，性能由于Vector。
- CopyOnWriteArrayList的写操作：加锁、复制数组、添加元素到复制数组、指向新数组、解锁

## ArrayList的并发异常？

⌨ **运行以下代码**

```java
public class ArrayListJucTest {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        for (int i = 0; i < 30; i++) {
            new Thread(() -> {
                list.add(UUID.randomUUID().toString().substring(0, 8));
                System.out.println(list);
            }, String.valueOf(i)).start();
        }
    }
}

```

🗑 **出现异常**：并发修改异常

```java
java.util.ConcurrentModificationException
```

📣 **导致原因**

快速失败（fail-fast）

🏷 **解决方案**

1 使用Vector（远古实现类，不推荐）

```java
List<String> list = new Vector<>();
```

2 使用线程安全工具类

```java
List<String> list = Collections.synchronizedList(new ArrayList<>());
```

3 使用CopyOnWriteArrayList（写时复制技术）

```java
List<String> list = new CopyOnWriteArrayList<>();
```

## 什么是快速失败（fail-fast）？

是Java集合的一种错误检测机制。在使用迭代器对集合进行遍历的时候，在多线程操作下，集合可能会触发fail-fast机制，导致抛出ConcurrentModificationException异常；在单线程下，如果在遍历过程中对集合对象的内容进行修改的话也会触发fail-fast机制。

因为当迭代器使用hashNext()或next()遍历下一个元素之前，都会检测modCount变量是否为expectedModCount值，是的话就返回遍历；否则抛出异常，终止遍历。如果在集合遍历期间对其进行修改，就会改变modCount的值，进而导致modCount != exceptedModCOunt，抛出异常。

阿里巴巴手册规定不要在foreach循环里进行元素的remove/add操作。要删除元素时使用Iterator的remove方法。如果并发操作，需要对Iterator对象加锁。

## CopyOnWrite 写时复制技术

CopyOnWrite简称COW。意思就是大家共同去访问一个资源，如果有人想要去修改这个资源的时候，就需要复制一个副本，去修改这个副本，而对于其他人来说访问得资源还是原来的，不会发生变化。

## 为什么使用hashcode？

hashcode是Object的方法，主要是为了在HashMap中存储使用，HashMap查找速度快，根据key的hashcode值生成数组下标，时间复杂度为O(1)。

在hash表中查找元素时，首先会比较两个元素的哈希值是否相等，如果相等的话再用equals()进行比较。

在JDK中，Object的hashcode方法是本地方法，也就是用c/c++实现的，直接返回对象的内存地址，所以重写hashcode方法是十分重要的。

在String中，计算方法为：`val[0]*31^(n-1) + val[1]*31^(n-2) + ... + val[n-1]`，字符串一样的String对象hashcode也一样。

> 使用31的原因？
>
> - 31是不大不小的质数，选择质数是为了降低哈希算法的哈希冲突。
> - 31可被JVM优化：`31 * i = (i << 5) - i`

## comparable和Comparator区别？

- **自然排序**：comparable接口出自java.lang包，它有一个compareTo(Object obj)方法用来排序。像String，包装类等实现了Comparable接口，重写了compareTo()方法。对于自定义类，如果需要排序的话，可以让自定义类实现Comparable接口，在compareTo()方法中指明如何排序。

  > 重写compareTo(obj)规则：
  >
  > 如果当前对象this  > 形参对象obj，返回正整数。
  >
  > 如果当前对象this  < 形参对象obj，返回负整数。
  >
  > 如果当前对象this  = 形参对象obj，返回零。

- **定制排序**：comparator接口出自 java.util包，它有一个compare(Object obj1, Object obj2)方法用来排序。当元素的类型没有实现Comparable接口又不方便修改时，或者实现了Compareble接口的排序规则不适合当前的操作，那么可以使用Comparator对象来排序。重写compare(Object o1, Object o2)。可以将Comparator传递给sort方法（如Collections.sort和Arrays.sort）。

  <img src="https://raw.githubusercontent.com/zouquchen/Images/main/imgs/sort_test3.png" alt="image-20220311143132968" style="zoom:50%;" />

- 比较：Comparable相当于内部比较器，Comparator相当于外部比较器。使用Comparable需要修改源码；使用Comparator不需要修改源码，而是另外实现比较。