---
title: ThreadLocal
date: 2022-07-13 16:28:42
permalink: /pages/14b9ec/
categories:
  - Java
  - Java并发编程
tags:
  - 
author: 
  name: Marvel
  link: https://github.com/zouquchen
---
# ThreadLocal

## ThreadLocal简介

通常情况下，我们创建的变量可以被任何一个线程访问并修改的。如果想实现每一个线程都自己的专属本地变量可以使用ThreadLocal类，ThreadLocal类主要解决的是让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可存储每个线程的私有数据。

如果创建了一个ThreadLocal变量，那么访问这个变量的线程都会有这个变量的本地副本。他们可以使用get()和set()方法来获取默认值或将其值更改为当前线程所存放的副本的值，避免线程安全问题。

**ThreadLocal示例**

```java
public class TestThreadLocal implements Runnable{

    private static final ThreadLocal<SimpleDateFormat> formatter = ThreadLocal.withInitial(() -> new SimpleDateFormat("yyyy MMdd HHmm"));

    @Override
    public void run() {
        System.out.println("Thread Name= "+Thread.currentThread().getName()+" default Formatter = "+formatter.get().toPattern());
        try {
            Thread.sleep(new Random().nextInt(1000));
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        //formatter pattern is changed here by thread, but it won't reflect to other threads
        formatter.set(new SimpleDateFormat());

        System.out.println("Thread Name= "+Thread.currentThread().getName()+" formatter = "+formatter.get().toPattern());
    }

    public static void main(String[] args) throws InterruptedException {
        TestThreadLocal obj = new TestThreadLocal();
        for (int i = 0; i < 10; i++) {
            Thread t = new Thread(obj, "" + i);
            Thread.sleep(new Random().nextInt(100));
            t.start();
        }
    }
}
```

虽然每个线程都修改了formatter的值，但是下一个线程输出的还是初始化的格式。



## ThreadLocal的理解？

ThreadLocal对象可以提供线程局部变量，每个线程拥有一份自己的副本变量，多个线程互不干扰。

创建一个ThreadLocal对象，每一个线程在往ThreadLocal里放值，就是往自己的ThreadLocalMap里存，读的时候也是以ThreadLocal作为引用，在自己的map里找对应的key来获取值。

最终的变量是放在当前的线程ThreadLocalMap中，并不是存在ThreadLocal上，ThreadLocal可以理解为只是ThreadLocalMap的封装，传递了变量值。

每一个Thread都具备一个ThreadLocalMap，而ThreadLocalMap可以存储以ThreadLocal为key，Object对象为value的键值对。

<img src="https://raw.githubusercontent.com/zouquchen/Images/main/imgs/threadlocal%E5%8E%9F%E7%90%86%E5%9B%BE2.png" alt="ThreadLocal数据结构" style="zoom:67%;" />

## ThreadLocal内存泄露问题？

ThreadLocalMap中使用的key为ThreadLocal的弱引用，而value是强引用。所以，如果ThreadLocal没有被外部引用的情况下，在垃圾回收的时候，key会被清理掉，而value不会被清理掉。这样一来，ThreadLocalMap中就会出现key为null的Entry。假如我们不做任何措施的话，value永远无法被GC回收，这时候就产生了内存泄漏。

ThreadLocalMap实现已经考虑了这种情况，在调用set、get、remove方法的时候，会清理掉key为null的记录。所以在使用ThreadLocal方法后，最好手动调用remove方法。

<img src="https://raw.githubusercontent.com/zouquchen/Images/main/imgs/threadlocal%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="image.png" style="zoom:67%;" />
