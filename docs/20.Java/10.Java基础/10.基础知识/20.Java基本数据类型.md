---
title: Java基本数据类型
date: 2022-07-13 16:28:42
permalink: /pages/702046/
categories:
  - Java
  - Java基础
  - 基础知识
tags:
  - Java
author: 
  name: Marvel
  link: https://github.com/zouquchen
---
# Java基本数据类型

**变量就是申请内存来存储值**。也就是说，当创建变量的时候，需要在内存中申请空间。

内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据。

Java 的两大数据类型:

- 内置数据类型
- 引用数据类型

## 1 内置数据类型

| 内置数据类型 | 对应的包装类 | 默认值  | 字节数                   |
| ------------ | ------------ | ------- | ------------------------ |
| byte         | Byte         | 0       | 1                        |
| short        | Short        | 0       | 2                        |
| int          | Integer      | 0       | 4                        |
| long         | Long         | 0L      | 8                        |
| float        | Float        | 0.0f    | 4                        |
| double       | Double       | 0.0d    | 8                        |
| char         | Character    | 'u0000' | 2                        |
| boolean      | Boolean      | false   | 1bit，实际上使用1或5字节 |

### byte

- byte 数据类型是8位、有符号的，以二进制补码表示的整数；
- 最小值是 **-128（-2^7）**；
- 最大值是 **127（2^7-1）**；
- 默认值是 **0**；
- byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；
- 例子：byte a = 100，byte b = -50。

### short

- short 数据类型是 16 位、有符号的以二进制补码表示的整数
- 最小值是 **-32768（-2^15）**；
- 最大值是 **32767（2^15 - 1）**；
- Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；
- 默认值是 **0**；
- 例子：short s = 1000，short r = -20000。

### int

- int 数据类型是32位、有符号的以二进制补码表示的整数；
- 最小值是 **-2,147,483,648（-2^31）**；
- 最大值是 **2,147,483,647（2^31 - 1）**；
- 一般地整型变量默认为 int 类型；
- 默认值是 **0** ；
- 例子：int a = 100000, int b = -200000。

### long

- long 数据类型是 64 位、有符号的以二进制补码表示的整数；
- 最小值是 **-9,223,372,036,854,775,808（-2^63）**；
- 最大值是 **9,223,372,036,854,775,807（2^63 -1）**；
- 这种类型主要使用在需要比较大整数的系统上；
- 默认值是 **0L**；
- 例子： **long a = 100000L**，**long b = -200000L**。
  "L"理论上不分大小写，但是若写成"l"容易与数字"1"混淆，不容易分辩。所以最好大写。

### float

- float 数据类型是单精度、32位、符合IEEE 754标准的浮点数；
- float 在储存大型浮点数组的时候可节省内存空间；
- 默认值是 **0.0f**；
- 浮点数不能用来表示精确的值，如货币；
- 例子：float f1 = 234.5f。

### double

- double 数据类型是双精度、64 位、符合 IEEE 754 标准的浮点数；

- 浮点数的默认类型为 double 类型；

- double类型同样不能表示精确的值，如货币；

- 默认值是 **0.0d**；

- 例子：

  ```java
  double   d1  = 7D ;
  double   d2  = 7.; 
  double   d3  =  8.0; 
  double   d4  =  8.D; 
  double   d5  =  12.9867; 
  ```

  7 是一个 int 字面量，而 7D，7. 和 8.0 是 double 字面量。

### boolean

- boolean数据类型表示一位的信息；
- 只有两个取值：true 和 false；
- 这种类型只作为一种标志来记录 true/false 情况；
- 默认值是 **false**；
- 例子：boolean one = true。

### char

- char 类型是一个单一的 16 位 Unicode 字符；
- 最小值是 **\u0000**（十进制等效值为 0）；
- 最大值是 **\uffff**（即为 65535）；
- char 数据类型可以储存任何字符；
- 例子：char letter = 'A';。

## 2 引用类型

- 在Java中，引用类型的变量非常类似于C/C++的指针。**引用类型指向一个对象，指向对象的变量是引用变量**。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。
- 对象、数组都是引用数据类型。
- 所有引用类型的默认值都是null。
- 一个引用变量可以用来引用任何与之兼容的类型。
- 例子：Site site = new Site("Runoob")。

## 3 Java常量

常量在程序运行时是不能被修改的。

在 Java 中使用 final 关键字来修饰常量，声明方式和变量类似：

```java
final double PI = 3.1415927;
```

虽然常量名也可以用小写，但为了便于识别，通常使用大写字母表示常量。

## 4 自动类型转换

**整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。**

转换从低级到高级。

```java
低  ------------------------------------>  高

byte,short,char—> int —> long—> float —> double 
```

数据类型转换必须满足如下规则：

- 不能对boolean类型进行类型转换。

- 不能把对象类型转换成不相关类的对象。

- 在把容量大的类型转换为容量小的类型时必须使用强制类型转换。

- 转换过程中可能导致溢出或损失精度，例如：

  ```java
  int i =128;   
  byte b = (byte)i;
  ```

  因为 byte 类型是 8 位，最大值为127，所以当 int 强制转换为 byte 类型时，值 128 时候就会导致溢出。

- 浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入，例如：

  ```java
  (int)23.7 == 23;        
  (int)-45.89f == -45
  ```

### 自动类型转换

必须满足转换前的数据类型的位数要低于转换后的数据类型，例如: short数据类型的位数为16位，就可以自动转换位数为32的int类型，同样float数据类型的位数为32，可以自动转换为64位的double类型。

```java
char c1='a';//定义一个char类型
int i1 = c1;//char自动类型转换为int    i1 = 97

char c2 = 'A';//定义一个char类型
int i2 = c2+1;//char 类型和 int 类型计算  i2 = 66
```

> c1 的值为字符 **a** ，查 ASCII 码表可知对应的 int 类型值为 97， A 对应值为 65

### 强制类型转换

条件是转换的数据类型必须是兼容的。

```java
int i1 = 123;
byte b = (byte)i1;  //强制类型转换为byte
```

## 5 常见问题

### 字符型常量和字符串常量的区别

1. 形式上：字符单引号引起一个字符，字符串双引号引起若干个字符
2. 含以上：字符常量相当于一个整型值（ASCII码），可以参加表达式运算；字符串常量代表一个地址值（该字符串在内存中存放位置）
3. 占内存大小：字符占2个字节；字符串占若干个字节。

### 浮点运算出现误差、精度丢失的问题

![image-20220712210326310](https://raw.githubusercontent.com/zouquchen/Images/main/imgs/float%20structure.png)

float类型占用32位，单精度浮点表示法：

- 符号位sign：1位，0表示正数，1表示负数
- 指数位exponent：8位，用来表示指数
- 小数位fraction：23位，用来表示小数，不足补零。

浮点一般采用**科学计数法**表示，而且我们常用的浮点都是很标准的，小数位几位，幂次几位等，所以随着数字数量级的增大，它能精确到的实际数字就会越来越粗糙，会出现**大数吃小数**的问题；

计算机内部是使用二进制表示浮点数的，而我们平时都是采用十进制表示数字，**二进制不能以有限位数来表示任意有限位数的十进制**，如0.1。因此金额运算一般都不会采用浮点，比如Java内就提供了`BigDecimal`进行任意精度的浮点运算。

## 如果商业运算会用什么数据类型？你知道它是怎么解决精度问题的吗？

BigDecimal

原理是，通过一个大整数来存储有效数字，再利用一个放缩因子来存储这个大整数实际上是精确到小数点后多少位。BigDecimal所代表的数字，就是这个 intVal * 10^(-scale)

BigInteger

符号位，通过一个int类型的数组来存储数据。