---
title: 静态代理与动态代理
date: 2022-07-18 15:16:40
permalink: /pages/da119c/
categories:
  - Java
  - Java基础
  - 进阶知识
tags:
  - 
author: 
  name: Marvel
  link: https://github.com/zouquchen
---

# 静态代理与动态代理

## 代理模式

简单来说就是 **我们使用代理对象来代替对真实对象的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。**

**代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。**



🔶 **三种角色**

- Real Subject：真实类，也就是被代理类、委托类。用来真正完成业务服务功能；
- Proxy：代理类。将自身的请求用 Real Subject 对应的功能来实现，代理类对象并不真正的去实现其业务功能；
- Subject：定义 RealSubject 和 Proxy 角色都应该实现的接口。

<img src="https://raw.githubusercontent.com/zouquchen/Images/main/imgs/proxy-partten1.png" alt="image-20220718154514730" style="zoom:45%;" />



🌰  **举个栗子**

<img src="https://raw.githubusercontent.com/zouquchen/Images/main/imgs/proxy-partten-example.png" alt="image-20220718152951538" style="zoom:67%;" />

- 房东（被代理类）：想要出租房屋，它的核心业务就是签合同和收钱，不想也无需做其他事情。
- 中介（代理类）：为房东增加额外的功能（服务），可以代替房东刊登广告、带房客看房等。
- 房客（调用者）：直接调用代理类的对象的出租房屋的方法，就可以看到广告，看房，最后签合同交钱。



⭐  **总结**

通过代理类，为原始类（目标类）增加额外的功能，利于原始类的维护。在上面的例子中，我们并没有修改房东类，而是添加了中介类为其增加了额外功能。

**为了保持行为的一致性，委托类和代理类都需要实现相同的接口**，这样在访问者看来两者之间就没有区别。通过代理类这个中间层，很好地隐藏和保护了委托类对象，能**有效屏蔽外界对委托类对象的直接访问**。

代理模式有**静态代理**和**动态代理**两种实现方式，我们先来看一下静态代理模式的实现。

## 静态代理

静态代理实现步骤:

1. 定义一个接口及其实现类；
2. 创建一个代理类同样实现这个接口
3. 将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。

下面通过代码展示：

**1.定义发送短信的接口**

```Java
public interface SmsService {
    String send(String message);
}
```

**2.实现发送短信的接口**

```Java
public class SmsServiceImpl implements SmsService {
    public String send(String message) {
        System.out.println("send message:" + message);
        return message;
    }
}
```

**3.创建代理类并同样实现发送短信的接口**

```Java
public class SmsProxy implements SmsService {

    private final SmsService smsService;

    public SmsProxy(SmsService smsService) {
        this.smsService = smsService;
    }

    @Override
    public String send(String message) {
        //调用方法之前，我们可以添加自己的操作
        System.out.println("before method send()");
        smsService.send(message);
        //调用方法之后，我们同样可以添加自己的操作
        System.out.println("after method send()");
        return null;
    }
}
```

**4.实际使用**

```Java
public class Main {
    public static void main(String[] args) {
        SmsService smsService = new SmsServiceImpl();
        SmsProxy smsProxy = new SmsProxy(smsService);
        smsProxy.send("java");
    }
}
```

运行上述代码之后，控制台打印出：

```Output
before method send()
send message:java
after method send()
```

可以输出结果看出，我们已经增加了 `SmsServiceImpl` 的`send()`方法。



**静态代理中，我们对目标对象的每个方法的增强都是手动完成的，非常不灵活且麻烦，比如接口一旦新增加方法，目标对象和代理对象都要进行修改，同时，我们需要对每个目标类都单独写一个代理类**。所以， 静态代理实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。

上面我们是从实现和应用角度来说的静态代理，从 JVM 层面来说， **静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件**。

## Java 字节码生成框架



## 动态代理

