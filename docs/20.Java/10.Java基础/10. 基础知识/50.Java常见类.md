---
title: Java常见类
date: 2022-07-13 16:28:42
permalink: /pages/492f52/
categories:
  - Java
  - Java基础
  -  基础知识
tags:
  - 
author: 
  name: Marvel
  link: https://github.com/zouquchen
---
# Java常见类 

## String、StringBuffer、StringBuilder区别？为什么String不可变？

String使用final关键字修饰的字符数组保存字符串，`private final char value[]`，所以String对象不可变。

> Java9之后改用byte数组存储字符串`private final byte value[]`，对于1个字节的节省空间，多字节的要编码。

`StringBuffer`与`StringBuilder`都是继承自`AbstractStringBuilder`类，在`AbstractStringBuilder`中使用字符数组保存字符串，但是没有用`final`和`private`关键字修饰，最关键的是`AbstractStringBuilder`类还提供了很多修改字符串的方法，比如append方法。

StringBuffer与StringBuilder的构造方法都是调用父类构造方法也就是AbstractStringBuilder实现的。

```java
abstract class AbstractStringBuilder implements Appendable, CharSequence {
    /**
     * The value is used for character storage.
     */
    char[] value;

    /**
     * The count is the number of characters used.
     */
    int count;

    AbstractStringBuilder(int capacity) {
        value = new char[capacity];
    }
}
```

**线程安全性**：

- String：对象是不可变的，线程安全。
- StringBuffer对方法加了同步锁或调用的方法加了同步锁，所以是线程安全的。
- StringBuffer并没有对方法进行同步加锁，所以是非线程安全的。

**性能：**

- String：每次改变String都会创建一个新的String对象，然后指针指向新的String对象。
- StringBuffer：每次对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。
- StringBuilder：相比StringBuffer的性能提升10%-15%，但线程不安全。

**总结：**

- 操作少量数据：String
- 单线程操作字符串缓冲区下大量数据：StringBuilder
- 多线程操作字符串缓冲区下大量数据：StringBuffer

## 字符串拼接用“+”还是StringBuilder？

“+”拼接方法，实际上是通过`StringBuilder`调用`append()`方法实现的，拼接完成之后调用`toString()`得到一个String对象。

在循环中使用“+”进行字符串的拼接的时候，编译器不会创建单个StringBuilder以复用，会导致创建过多的StringBuilder对象。

## String#equals()和Object#equals()有何区别？

String的equals方法被重写过，比较的是String字符串的值是否相等。

Object的equals方法比较的对象的内存地址。

## 字符串常量池的作用？在内存的哪部分？

字符串常量池是JVM为了提升性能和减少内存消耗，针对于字符串专门开辟的一块区域，主要是为了避免字符串被重复创建。

```java
String aa = "ab"; // 放在常量池中
String bb = "ab"; // 从常量池中查找
System.out.println(aa==bb);// true
```

JDK1.7之前，运行时常量池逻辑包含字符串常量池，放在方法区。

JDK1.7，字符串常量池从方法区拿到了堆中。

## String s = new String("abc")创建几个对象？

当字符串常量池中存在“abc”字面量时，创建一个对象，堆中的字符串对象。

当字符串常量池中不存在"abc"字面量时，创建两个对象，堆中的字符串对象和字符串常量池中的字面量对象。

## intern()方法？

`String::intern()`是一个本地方法，它的作用是如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中整个字符串的String对象的引用；否则，会将此String对象包含的字符串添加到常量池，并且返回此String对象的引用。

```java
String s1 = new StringBuffer("re").append("dis").toString();
System.out.println(s1 == s1.intern()); // true

String s2 = new StringBuffer("ja").append("va").toString();
System.out.println(s2 == s2.intern()); // false
```

为什么java不同呢？因为有一个初始化的java字符串（JDK自带），在加载sun.misc.Version这个类的时候进入常量池。

System类中有`initializeSystemClass`方法，该方法调用`sun.misc.Version.init()`，Version这类中与常量java。

## Object类的常见方法

```java
//native⽅法，⽤于返回当前运⾏时对象的Class对象，使⽤了final关键字修饰，故不允许⼦类重写。
public final native Class<?> getClass()

//native⽅法，⽤于返回对象的哈希码，主要使⽤在哈希表中，⽐如JDK中的HashMap。
public native int hashCode() 

//⽤于⽐较2个对象的内存地址是否相等，String类对该⽅法进⾏了重写⽤户⽐较字符串的值是否相等。
public boolean equals(Object obj)

//naitive⽅法，⽤于创建并返回当前对象的⼀份拷⻉。⼀般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为true。Object本身没有实现Cloneable接⼝，所以不重写clone⽅法并且进⾏调⽤的话会发⽣CloneNotSupportedException异常。
protected native Object clone() throws CloneNotSupportedException

//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的⼦类都重写这个⽅法。
public String toString()

//native⽅法，并且不能重写。唤醒⼀个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒⼀个。
public final native void notify()

//native⽅法，并且不能重写。跟notify⼀样，唯⼀的区别就是会唤醒在此对象监视器上等待的所有线程，⽽不是⼀个线程。
public final native void notifyAll()

//native⽅法，并且不能重写。暂停线程的执⾏。注意：sleep⽅法没有释放锁，⽽wait⽅法释放了锁 。timeout是等待时间。
public final native void wait(long timeout) throws InterruptedException

//多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。
public final void wait(long timeout, int nanos) throws InterruptedException

//跟之前的2个wait⽅法⼀样，只不过该⽅法⼀直等待，没有超时时间这个概念
public final void wait() throws InterruptedException

//实例被垃圾回收器回收的时候触发的操作
protected void finalize() throws Throwable { }
```

## 