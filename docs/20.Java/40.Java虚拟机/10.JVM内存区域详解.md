---
title: JVM内存区域详解
date: 2022-07-13 18:29:52
permalink: /pages/6198af/
categories:
  - Java
  - Java虚拟机
tags:
  - Java
  - JVM
author: 
  name: Marvel
  link: https://github.com/zouquchen
---
# JVM内存区域详解

## 运行时数据区

Java内存区域就是运行时数据区。

<img src="https://raw.githubusercontent.com/zouquchen/Images/main/imgs/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.png" alt="JVM内存区域" style="zoom:80%;" />

按照线程私有和共享进行区分的话。私有部分包含：程序计数器、虚拟机栈、本地方法栈；共享部分包含：堆、方法区

- **程序计数器**：线程私有，用于记录当前线程下条指令的位置，不会因为线程的切换而忘记当前线程所执行到的位置；分支、循环、跳转、异常处理、线程恢复都需要程序计数器来完成。程序计数器占的空间非常小，并且不会出现`OutOfMemeryError`，他会随着线程创建而创建，线程的结束而结束。
- **虚拟机栈**：线程私有，由一个个栈帧组成，每一个栈帧对应一个方法，每一个方法的调用到执行完成对应着栈帧的入栈和出栈，每个栈帧都包含局部变量表、操作数栈、动态链接、方法返回地址。会出现`StackOverFlowError`和`OutOfMemeryError`两种错误。
- **本地方法栈**：线程私有，虚拟机栈执行的是Java方法，本地方法栈则使用虚拟机的Native方法。本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放本地方法的局部变量表、操作数栈、动态链接、出口信息。也会出现`StackOverFlowError`和`OutOfMemoryError`两种错误。
- **堆**：线程共享，存放对象实例，几乎所有对象实例以及数组都在这里分配内存。堆主要分为两部分：新生代（Eden、Survivor）和老生代（Old），分为两部分有利于垃圾回收，因为垃圾回收的主要区域就是堆。
- **方法区**：用于存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

### 程序计数器

线程私有，用于记录当前线程下条指令的位置，不会因为线程的切换而忘记当前线程所执行到的位置；分支、循环、跳转、异常处理、线程恢复都需要程序计数器来完成。程序计数器占的空间非常小，并且不会出现`OutOfMemeryError`，他会随着线程创建而创建，线程的结束而结束。

### 虚拟机栈

线程私有，由一个个栈帧组成，每一个栈帧对应一个方法，每一个方法的调用到执行完成对应着栈帧的入栈和出栈，每个栈帧都包含局部变量表、操作数栈、动态链接、方法返回地址。会出现`StackOverFlowError`和`OutOfMemeryError`两种错误。

#### 局部变量表

主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。

#### 动态链接

主要服务一个方法需要调用其他方法的场景。在 Java 源文件被编译成字节码文件时，所有的变量和方法引用都作为符号引用保存在 Class 文件的常量池里。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。动态链接的作用就是为了将符号引用转换为调用方法的直接引用。

![image-20220715162225937](https://raw.githubusercontent.com/zouquchen/Images/main/imgs/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5.png)

#### 操作数栈

主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果。另外，计算过程中产生的临时变量也会放在操作数栈中。

#### 方法返回地址

返回方法被调用的位置。

### 本地方法栈

线程私有，虚拟机栈执行的是Java方法，本地方法栈则使用虚拟机的Native方法。本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放本地方法的局部变量表、操作数栈、动态链接、出口信息。也会出现`StackOverFlowError`和`OutOfMemoryError`两种错误。

### 堆

线程共享，存放对象实例，几乎所有对象实例以及数组都在这里分配内存。堆主要分为两部分：新生代（Eden、Survivor）和老生代（Old），分为两部分有利于垃圾回收，因为垃圾回收的主要区域就是堆。

堆最容易出现的就是 `OutOfMemoryError` 错误，并且出现这种错误之后的表现形式还会有几种，比如：

1. `java.lang.OutOfMemoryError: GC Overhead Limit Exceeded` ： 当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。
2. `java.lang.OutOfMemoryError: Java heap space` ：假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。(和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过`-Xmx`参数配置，若没有特别配置，将会使用默认值。

### 方法区

用于存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

- JDK1.8：在元空间内，直接使用内存，内存受系统的限制。
- JDK1.7：方法区与堆地址相连，实现方式是永久代

## 常见问题

### 如何快速填满堆？

### 如何快速填满虚拟机栈？

### 如何快速填满方法去？

### 本地方法栈有什么用？

本地方法栈与虚拟机栈所发挥的作用非常相似，区别只是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则是为了虚拟机使用本地方法服务。

### 没有程序计数器会怎么样？

Java程序中的流程控制无法得到正确的控制，多线程也无法正确的轮换。

### 类存放在哪里？

方法区，用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

### 局部变量存放在哪里？

虚拟机栈，线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机中从入栈到出栈的过程。

局部变量表存放了编译期可知的各种Java虚拟机基本数据、对象引用和returnAddress类型。

### 方法区和运行时常量池溢出？

运行时常量池是方法区的一部分。

`String::intern()`是一个本地方法，它的作用是如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中整个字符串的String对象的引用；否则，会将此String对象包含的字符串添加到常量池，并且返回此String对象的引用。