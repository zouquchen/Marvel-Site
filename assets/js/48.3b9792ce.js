(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{372:function(a,s,t){"use strict";t.r(s);var v=t(3),n=Object(v.a)({},(function(){var a=this,s=a._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"jvm类的加载过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jvm类的加载过程"}},[a._v("#")]),a._v(" JVM类的加载过程")]),a._v(" "),s("h2",{attrs:{id:"_1-类的生命周期"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-类的生命周期"}},[a._v("#")]),a._v(" 1 类的生命周期")]),a._v(" "),s("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://raw.githubusercontent.com/zouquchen/Images/main/imgs/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png",alt:"image-20220304184144243"}}),a._v(" "),s("h2",{attrs:{id:"_2-类的加载过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-类的加载过程"}},[a._v("#")]),a._v(" 2 类的加载过程")]),a._v(" "),s("p",[a._v("系统加载Class类的文件主要分为三步：加载、连接、初始化。链接过程包括：验证、准备、解析")]),a._v(" "),s("ol",[s("li",[s("p",[s("strong",[a._v("加载")]),a._v("：")]),a._v(" "),s("ol",[s("li",[a._v("通过一个类的全限定名获取定义此类的二进制字节流")]),a._v(" "),s("li",[a._v("将这个类的元数据存储在方法区。（将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构）")]),a._v(" "),s("li",[a._v("将这个类的"),s("code",[a._v("java.lang.Class")]),a._v("对象存储在堆中。（在内存中生成一个代表这个类的 "),s("code",[a._v("java.lang.Class")]),a._v(" 对象，作为方法区这个类的各种数据的访问入口）")])]),a._v(" "),s("blockquote",[s("p",[a._v("字节码来源：本地路径下编译生成的"),s("code",[a._v(".class")]),a._v("文件；jar包中的"),s("code",[a._v(".class")]),a._v("文件；从远程网络以及动态代理实时编译的。")])])]),a._v(" "),s("li",[s("p",[s("strong",[a._v("连接-验证")]),a._v("：为了保证加载进来的字节流符合虚拟机规范，不会造成安全错误。大致上完成四个阶段的检验：")]),a._v(" "),s("ol",[s("li",[a._v("文件格式验证：是否符合 class 文件的规范")]),a._v(" "),s("li",[a._v("元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java 语言规范")]),a._v(" "),s("li",[a._v("字节码验证：确保程序语义是合法的、符合逻辑的。")]),a._v(" "),s("li",[a._v("符号引用验证：确保解析动作能正确执行。")])])]),a._v(" "),s("li",[s("p",[s("strong",[a._v("连接-准备")]),a._v("：为类变量分配内存并设置类变量默认初始值，即零值。")]),a._v(" "),s("blockquote",[s("p",[a._v("不包含final修饰的static，因为final在编译的时候就会分配好了默认值，准备阶段会显式初始化。")])])]),a._v(" "),s("li",[s("p",[s("strong",[a._v("连接-解析")]),a._v("：虚拟机将常量池内的符号引用转换为直接引用。")]),a._v(" "),s("blockquote",[s("p",[a._v("符号引用：以一组符号（字符串）来描述所引用的目标，这个字符串给出了一些能够唯一标识一个方法、一个变量、一个类的相关信息。")]),a._v(" "),s("p",[a._v("直接引用：可以理解为一个内存地址，或者一个偏移量，或者是一个能间接定位到目标的句柄。")]),a._v(" "),s("p",[a._v("例子：调用方法hello()；方法的地址是123456，则hello是符号引用，12345是直接引用。")])])]),a._v(" "),s("li",[s("p",[s("strong",[a._v("初始化")]),a._v("：执行类初始化方法 "),s("code",[a._v("<client>")]),a._v(" 的过程。对于初始化方法的调用，虚拟机会确保在多线程环境中的安全性（因为初始化方法带锁）。对于初始化阶段，虚拟机严格规范了有且只有6种情况，必须对类进行初始化：")]),a._v(" "),s("ol",[s("li",[s("p",[a._v("当遇到new、getstatic、putstatic、invokestatic这四条字节码指令时。")]),a._v(" "),s("blockquote",[s("p",[a._v("new 创建实例；getstatic 访问静态变量；pustatic 给静态变量赋值；invokestatic 调用静态方法。")])])]),a._v(" "),s("li",[s("p",[a._v("使用反射时.")])]),a._v(" "),s("li",[s("p",[a._v("初始化一个类，其父类还未初始化，则先初始化父类。")])]),a._v(" "),s("li",[s("p",[a._v("当虚拟机启动时，用户需要定义一个要执行的主类（包含main方法的类），虚拟机会先初始化这个类。")])]),a._v(" "),s("li",[s("p",[a._v("动态用语言相关（略）")])]),a._v(" "),s("li",[s("p",[a._v("包含默认方法（被default关键字修饰的接口方法）的接口的实现类发生初始化，要先初始化接口。")])])])])]),a._v(" "),s("h2",{attrs:{id:"_3-三个重要的类加载器classloader"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-三个重要的类加载器classloader"}},[a._v("#")]),a._v(" 3 三个重要的类加载器ClassLoader")]),a._v(" "),s("ul",[s("li",[a._v("BootStrapClassLoader启动类加载器：由 c++ 实现，负责加载lib目录下的jar包或被 "),s("code",[a._v("-Xbootclasspath")]),a._v("参数指定的路径中的所有类。")]),a._v(" "),s("li",[a._v("ExtensionClassLoader扩展类加载器：Java 实现，主要负责 "),s("code",[a._v("lib/ext")]),a._v(" 目录下的jar包，或被  "),s("code",[a._v("java.ext.dirs")]),a._v(" 系统变量所指定的路径下的 jar 包。")]),a._v(" "),s("li",[a._v("AppClassLoader应用程序类加载器：面向用户的加载器，负责加载当前应用 classpath 下的所有 jar 包。")])]),a._v(" "),s("blockquote",[s("p",[a._v("AppClassLoader 的父加载器为 ExtensionClassLoader")]),a._v(" "),s("p",[a._v("ExtensionClassLoader 的父加载器为 null，并不带代表没有父类加载器，而是 BootStrapClassLoader。")])]),a._v(" "),s("h2",{attrs:{id:"_4-双亲委派模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-双亲委派模型"}},[a._v("#")]),a._v(" 4 双亲委派模型")]),a._v(" "),s("p",[a._v("如果一个类加载器收到了加载某个类的请求，则该类加载器并不会去加载该类，而是把这个请求委派给父类加载器（调用父类的loadClass方法），每一个层级的类加载器都是如此，因此所有类加载请求最终都会传送到顶端的启动类加载器；只有当父类加载器在其搜索范围内无法找到所需的类，子类加载器才会尝试自己去加载。")]),a._v(" "),s("p",[s("strong",[a._v("为什么使用双亲委派模型：")])]),a._v(" "),s("ul",[s("li",[s("p",[a._v("对于任意一个类，都需要"),s("strong",[a._v("加载它的类加载器")]),a._v("和这个"),s("strong",[a._v("类本身")]),a._v("来一同确立其在 Java 虚拟机中的"),s("strong",[a._v("唯一性")]),a._v("。")])]),a._v(" "),s("li",[s("p",[a._v("如果不是同一个类加载器加载，即使是相同 class 文件，也会出现判断不相同的情况，从而引发一些意想不到的情况，为了保证相同的 class 文件，在使用的时候是相同的对象，JVM 设计的时候，采用双亲委派的方式来加载类。")])])]),a._v(" "),s("p",[s("strong",[a._v("好处：")])]),a._v(" "),s("ul",[s("li",[s("strong",[a._v("避免类的重复加载")]),a._v("。Java 类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关系可以避免类的重复加载，当父亲已经加载了该类时，子类就没必要加在了。")]),a._v(" "),s("li",[s("strong",[a._v("保证Java核心API不被篡改")]),a._v("。假设通过网络传递一个名为 "),s("code",[a._v("java.lang.Integer")]),a._v(" 的类名，通过双亲委派模型传递到启动类加载器，而启动类加载器在核心API发现这个名字的类已被加载，就不会重新加载网络上传递过来的 "),s("code",[a._v("java.lang.Integer")]),a._v("，而是直接返回已加载过的 "),s("code",[a._v("Integer.class")]),a._v("。")])]),a._v(" "),s("h2",{attrs:{id:"_5-能否自定义一个java-lang-object类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-能否自定义一个java-lang-object类"}},[a._v("#")]),a._v(" 5 能否自定义一个java.lang.Object类？")]),a._v(" "),s("p",[a._v("类加载过程会遵循双亲委派原则，当一个类首次被加载时，会依次向上级类加载器委托，直到最顶层的 BootStrapClassLoader。"),s("code",[a._v("java.lang.Object")]),a._v(" 属于系统类，会由 BootStrapClassLoader 优先加载，最终加载的还是系统原生的 "),s("code",[a._v("java.lang.Object")]),a._v(" 类，因此会报找不到 main 方法的错误。")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("package")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token namespace"}},[a._v("java"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("lang")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" args"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("System")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("out"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"test"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br")])]),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("错误: 在类 java.lang.Object 中找不到 main 方法, 请将 main 方法定义为:\n   public static void main(String[] args)\n否则 JavaFX 应用程序类必须扩展javafx.application.Application\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br")])]),s("p",[a._v("正常情况下类加载过程会遵循双亲委派机制，依次向上级类加载器委托加载，上级都加载不了，才会自行加载。")]),a._v(" "),s("p",[a._v("如果想要绕过双亲委派机制，需要重写 ClassLoader 类中的 loadClass 方法，一般不推荐这么做。由于 final 方法 defineClass 的限制，正常情况下我们无法加载以 "),s("code",[a._v("java.")]),a._v(" 开头的系统类。一般自定义类加载器只需要实现 ClassLoader 的 findClass 方法来加载自定义路径下的类，而不是覆写 loadClass 破坏双亲委派，避免带来系统安全隐患。")])])}),[],!1,null,null,null);s.default=n.exports}}]);