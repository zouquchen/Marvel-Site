(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{356:function(a,s,t){"use strict";t.r(s);var e=t(3),r=Object(e.a)({},(function(){var a=this,s=a._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"hashmap常见知识点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashmap常见知识点"}},[a._v("#")]),a._v(" HashMap常见知识点")]),a._v(" "),s("h2",{attrs:{id:"hashmap的hash算法实现原理-扰动函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashmap的hash算法实现原理-扰动函数"}},[a._v("#")]),a._v(" hashMap的hash算法实现原理（扰动函数）？")]),a._v(" "),s("p",[a._v("hashMap的hash算法是为了使散列表分布的更加均匀。")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("final")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("hash")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v(" key"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" h"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("key "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("?")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("h "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" key"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("hashCode")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("^")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("h "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">>>")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("16")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br")])]),s("p",[a._v("获取元素的索引为(length - 1) & hash，由于length不会很长，这样就会导致高位的hash值用不上，不同的hashcode在hashmap中可能会得到相同的位置索引（hashcode()是计算对象的hash值，hash()是hashmap中对原对象hash值的重新计算，计算之后减少哈希冲突）。所以把高16位的hashcode与低16位异或，此时高16位不变，低16位会发生改变。")]),a._v(" "),s("p",[a._v("在使用hashmap的get方法时，会通过"),s("code",[a._v("tab[(n - 1) & hash])")]),a._v("获取元素的索引。")]),a._v(" "),s("blockquote",[s("p",[a._v("length = 2 ^ n，默认大小length = 2 ^ 4 = 16，length - 1 = 15 = 11111")])]),a._v(" "),s("h2",{attrs:{id:"介绍一下hashmap的实现原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#介绍一下hashmap的实现原理"}},[a._v("#")]),a._v(" 介绍一下HashMap的实现原理？")]),a._v(" "),s("p",[a._v("有一个Entry数组，Entry里面包含key和value。当要添加一组键值对的时候，会根据hash算法算出key所对应的hash值，通过数组大小n-1 & hash值后，得到一个数组的下标，最后把Entry放到这个位置。")]),a._v(" "),s("p",[a._v("因为，hash算法可能会产生冲突，且数组大小是有限的，所以很可能通过不同的key计算得到一样的下标，为了解决Entry存放冲突的问题，采用链表法实现，在该位置引出一个链表，用于存储冲突的Entry。")]),a._v(" "),s("p",[a._v("在jdk1.7之前，链表法采用的是头插法，即在链表头处插入新的Entry；在jdk1.8之后，采用尾插法，并且引入红黑树。当链表长度大于8且数组长度大于等于64时，把链表转化为红黑树，当红黑树节点小于6时，又会退化为链表。")]),a._v(" "),s("h2",{attrs:{id:"为什么jdk1-8要对hashmap做红黑树这个改动"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么jdk1-8要对hashmap做红黑树这个改动"}},[a._v("#")]),a._v(" 为什么JDK1.8要对HashMap做红黑树这个改动？")]),a._v(" "),s("p",[a._v("主要是为了避免hash冲突导致链表过长，这样get的时间复杂度就不是O(1)了，因为可能需要遍历链表来查找Entry。")]),a._v(" "),s("h2",{attrs:{id:"为什么定义链表长度为8且数组大小大于等于64才转红黑树-不要链表直接用红黑树不行吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么定义链表长度为8且数组大小大于等于64才转红黑树-不要链表直接用红黑树不行吗"}},[a._v("#")]),a._v(" 为什么定义链表长度为8且数组大小大于等于64才转红黑树？不要链表直接用红黑树不行吗？")]),a._v(" "),s("p",[a._v("因在HashMap的注释中写道：")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Because")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("TreeNodes")]),a._v(" are about twice the size of regular nodes"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("p",[a._v("因为红黑树节点的大小是普通节点大小的两倍，所以为了节省内存空间不会直接使用红黑树，只有达到一定数量才会转成红黑树，这里定义的是8.")]),a._v(" "),s("p",[a._v("为什么是8呢，HashMap的注释中有写到：")]),a._v(" "),s("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://raw.githubusercontent.com/zouquchen/Images/main/imgs/concurrentHashMap.png",alt:"image-20220306185832957"}}),a._v(" "),s("p",[a._v("和泊松分布有关，在阈值为0.75的情况下，理论冲突节点长度为8的概率为0.00000006，小于千万分之一，是非常小的概率。")]),a._v(" "),s("p",[a._v("这就是基于时间和空间的平衡，红黑树占用内存大，所以节点少的时候就不用红黑树，如果万一真的冲突很多，就用红黑树，选择参数为8的大小，就是为了平很时间和空间问题。")]),a._v(" "),s("h2",{attrs:{id:"为什么节点小于6要从红黑树转成链表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么节点小于6要从红黑树转成链表"}},[a._v("#")]),a._v(" 为什么节点小于6要从红黑树转成链表？")]),a._v(" "),s("p",[a._v("同样是为了平衡时间和空间，节点太少链表遍历也很快，没必要使用红黑树，变成链表节约内存。为什么是6而不是8呢？因为要六个缓存余地，避免反复横跳。")]),a._v(" "),s("h2",{attrs:{id:"hashmap源码底层结构分析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashmap源码底层结构分析"}},[a._v("#")]),a._v(" HashMap源码底层结构分析？")]),a._v(" "),s("p",[a._v("HashMap底层：数组 + 链表 +红黑树")]),a._v(" "),s("p",[a._v("通过使用链表和红黑树来解决哈希冲突，链表长度大于阈值（默认位8）时，会调用"),s("code",[a._v("treeifyBin()")]),a._v("来决定时扩充数组还是将链表转换为红黑树。只有当数组长度大于64情况下，才会执行转换红黑树操作，否则执行"),s("code",[a._v("resize()")]),a._v("来扩充数组。")]),a._v(" "),s("p",[s("strong",[a._v("loadFactor负载因子")])]),a._v(" "),s("p",[a._v("控制数组疏密程度，loadFactor越趋近于1，数组中存放的数据越多，链表越长，越趋近于0，数组中存放的数据越少。loadfactor太大导致查找元素效率低，太小会导致数组利用率低。")]),a._v(" "),s("p",[s("strong",[a._v("threshold扩容阈值")])]),a._v(" "),s("p",[a._v("threshold = capacity * loadFactor，当size >= threshold就对数组进行扩容。")]),a._v(" "),s("p",[a._v("loadFactor的默认值位0.75，数组的默认容量位16，所以当数据量达到"),s("code",[a._v("16*0.75=12")]),a._v("时就会扩容。")]),a._v(" "),s("h2",{attrs:{id:"hashmap为什么线程不安全-举例说明。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashmap为什么线程不安全-举例说明。"}},[a._v("#")]),a._v(" HashMap为什么线程不安全？举例说明。")]),a._v(" "),s("p",[a._v("JDK1.7中，当并发执行扩容操作时容易形成环链造成死循环")]),a._v(" "),s("p",[a._v("JDK1.8中，当并发执行put操作时会发送数据覆盖的情况。")]),a._v(" "),s("p",[a._v("https://blog.csdn.net/zzu_seu/article/details/106669757")]),a._v(" "),s("h2",{attrs:{id:"hashmap的put和get方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashmap的put和get方法"}},[a._v("#")]),a._v(" HashMap的put和get方法？")]),a._v(" "),s("p",[s("strong",[a._v("put方法")])]),a._v(" "),s("p",[a._v("put方法中调用putVal方法，putVal并不提供给用户使用。")]),a._v(" "),s("p",[s("strong",[a._v("putVal方法")])]),a._v(" "),s("ol",[s("li",[a._v("判断数组是否为空或者长度为0，如果是就要resize扩容。")]),a._v(" "),s("li",[a._v("根据hash计算数组下标，如果定位到数组位置没有元素，直接插入。")]),a._v(" "),s("li",[a._v("如果定位到数组位置有元素，就要和插入的key比较，如果key相同就直接覆盖。")]),a._v(" "),s("li",[a._v("如果key不同，就判断p是否是一个树节点，若是树节点，就调用将元素添加进入树节点；如果不是树节点，就遍历链表插入链表尾部。")]),a._v(" "),s("li",[a._v("如果链表长度大于8，且数组长度小于64，需要对数组进行扩容；如果链表长度大于8，数组长度不小于64，需要将链表转化为红黑树。")]),a._v(" "),s("li",[a._v("如果元素个数大于扩容阈值threshold，需要对数组进行扩容。")])]),a._v(" "),s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/zouquchen/Images/main/imgs/put%E6%96%B9%E6%B3%95.png",alt:" "}})]),a._v(" "),s("p",[s("strong",[a._v("get方法")])]),a._v(" "),s("p",[a._v("get方法会调用getNode方法。")]),a._v(" "),s("p",[s("strong",[a._v("getNode方法")])]),a._v(" "),s("p",[a._v("根据hash值和key获取节点信息，如果找不到对象则返回null。")]),a._v(" "),s("h2",{attrs:{id:"hashmap扩容原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashmap扩容原理"}},[a._v("#")]),a._v(" HashMap扩容原理？")]),a._v(" "),s("p",[a._v("默认容量16，默认加载因子0.75，当HashMap中元素超过容量*加载因子时会进行扩容。")]),a._v(" "),s("h2",{attrs:{id:"concurrenthashmap结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#concurrenthashmap结构"}},[a._v("#")]),a._v(" ConcurrentHashMap结构")]),a._v(" "),s("p",[a._v("jdk1.7：由多个Segment组成，一个Segment就类似于一个HashMap的结构，每一个Segment可以扩容，但Segment的个数一旦初始化就不能改变，默认Segment时16个，所以可以认为ConcurrentHashMap默认支持16个线程并发。")]),a._v(" "),s("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://raw.githubusercontent.com/zouquchen/Images/main/imgs/hashmap%E6%B3%A8%E9%87%8A.png",alt:"image-20220302163940416"}}),a._v(" "),s("p",[a._v("Jdk1.8：使用Synchronized锁加CAS机制，结构从Segment数组+HashEntry数组+链表进化成了Node数组+链表/红黑树，Node是类似于一个HashEntry的结构，他的冲突达到一定大小时会转化成红黑树，冲突小于一定数量时会退回链表。")]),a._v(" "),s("h2",{attrs:{id:"hashmap与concurrenthashmap在jdk1-7和jdk1-8的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashmap与concurrenthashmap在jdk1-7和jdk1-8的区别"}},[a._v("#")]),a._v(" HashMap与ConcurrentHashMap在JDK1.7和JDK1.8的区别？")]),a._v(" "),s("p",[a._v("HashMap：")]),a._v(" "),s("ul",[s("li",[a._v("JDK1.7之前，基于数组和链表实现的，链表采用头插法。")]),a._v(" "),s("li",[a._v("JDK1.8之后，在解决Hash冲突的时候有了较大的变化，当链表长度大于阈值（默认为8）时将链表转化为红黑树，以减少搜索时间，链表采用尾插法。将链表转化为红黑树前会判断，如果当前数组长度小于64，那么会选择先扩容，而不是转换为红黑树。")])]),a._v(" "),s("p",[a._v("ConcurrentHashMap:")]),a._v(" "),s("ul",[s("li",[a._v("JDK1.7之前，基于分段数组和链表实现的，使用分段锁segment，每一把锁只锁容器中一部分数据，多线程访问容器里不同数据段的数据就不会存在锁竞争的情况，提高并发访问效率。")]),a._v(" "),s("li",[a._v("JDK1.8之后，摒弃Segemtn概念，直接使用Node数组+链表/红黑树，并发控制使用synchronized和CAS来操作。synchronized只锁定当前链表或红黑树的首节点。")])]),a._v(" "),s("h2",{attrs:{id:"为什么-hashmap-的-size-为-2-的冥次方"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么-hashmap-的-size-为-2-的冥次方"}},[a._v("#")]),a._v(" 为什么 HashMap 的 size 为 2 的冥次方？")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("为了使 hash 表中的"),s("strong",[a._v("数分布更均匀")]),a._v("，某个数在 hash 数组中的位置计算公式为hash(key) & (len-1)，此时当(len-1)为 1111，即 len 为 2 的幂次方大小时分布之最均匀，故采用两倍扩容的方式。")])]),a._v(" "),s("li",[s("p",[a._v("当 length 总是 2 的 n 次方时,h& (length-1)运算等价于对 length 取模,也就是 h%length,但是&比%具有更高的效率。")])]),a._v(" "),s("li",[s("p",[a._v("当数组长度为 2 的 n 次幂的时候,不同的 key 算得的 index 相同的几率较小,那么 数据在数组上分布就比较均匀,也就是说碰撞的几率小,相对的,查询的时候就不用遍历某个位置上的链表,这样查询效率也就较高了。")])])]),a._v(" "),s("h2",{attrs:{id:"hashcode介绍"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashcode介绍"}},[a._v("#")]),a._v(" HashCode介绍？")]),a._v(" "),s("p",[a._v("hashCode()作用是获取哈希码（散列码），返回是int，哈希码的作用是确定该对象在哈希表中的索引位置。hashCode()是Object中的方法，是本地方法，也就是用c/c++实现的，通常是用来将对象的内存地址转换为整数之后返回。")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("native")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("hashCode")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("p",[a._v("散列表存储的是键值对（key-value）：能根据键快速检索出对应的值。")]),a._v(" "),s("h2",{attrs:{id:"为什么要有hashcode"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么要有hashcode"}},[a._v("#")]),a._v(" 为什么要有hashCode？")]),a._v(" "),s("p",[a._v("以HashSet为例，当把对象加入HashSet时，首先计算对象的hashCode值来判断对象加入的位置，同时会与其他已经加入的对象的hashCode作比较，如果没有相符合的hashCode，hashSet会假设这个对象没有出现过；如果发现有相同hashcode值的对象，会调用equals()方法来检查对象是否真的相等，如果相同，hashset就不让其加入。如果不同，就会重新散列到其他位置。这样就大大减少equals的次数，提高执行效率。")]),a._v(" "),s("h2",{attrs:{id:"为什么要重写equals时必须重写hashcode方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么要重写equals时必须重写hashcode方法"}},[a._v("#")]),a._v(" 为什么要重写equals时必须重写hashCode方法？")]),a._v(" "),s("p",[a._v("如果两个对象相等，那么hashCode一定相同。两个对象具有相同的hashcode值，他们却不一定相等。因此，equals方法被覆盖了，hashCode方法也要重写，以确保相同的对象有相同的hashcode。")])])}),[],!1,null,null,null);s.default=r.exports}}]);