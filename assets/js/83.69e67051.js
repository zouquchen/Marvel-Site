(window.webpackJsonp=window.webpackJsonp||[]).push([[83],{407:function(e,s,_){"use strict";_.r(s);var t=_(3),r=Object(t.a)({},(function(){var e=this,s=e._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"redis分布式锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis分布式锁"}},[e._v("#")]),e._v(" Redis分布式锁")]),e._v(" "),s("h4",{attrs:{id:"_1-redis分布式锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-redis分布式锁"}},[e._v("#")]),e._v(" 1 Redis分布式锁")]),e._v(" "),s("p",[s("strong",[e._v("原理")]),e._v("：多个服务，同一时刻内请求同一个共享资源，为防止关键业务出现数据冲突和并发错误，需要加分布式锁。")]),e._v(" "),s("p",[s("strong",[e._v("实现")]),e._v("："),s("code",[e._v("set <key> <value> [EX seconds] [PX milliseconds] [NX|XX]")]),e._v("，如果key不存在就设置键值对并带有过期时间，如果存在就设置失败。")]),e._v(" "),s("p",[s("strong",[e._v("注意点")]),e._v("：")]),e._v(" "),s("ol",[s("li",[e._v("设置Key的同时要设置过期时间，防止服务突然宕机，后续锁无法释放。设置key和过期时间的过程要保证原子性。")]),e._v(" "),s("li",[e._v("如果业务A执行的时间太长，锁已经过期了，此时其他线程获取了锁。当业务A执行完毕，此时将释放其他线程的锁，这将导致一系列问题。所以在释放锁的时候要通过Value判断是不是自己加的锁。（所以，value的选择要唯一，保证每一个服务线程的值是唯一的）")]),e._v(" "),s("li",[e._v("需要保证判断”是不是自己的锁“和”释放锁“的过程是原子性的，最常用的方法是写LUA脚本，也可以通过Redis的事务实现。")])]),e._v(" "),s("p",[s("strong",[e._v("其他高级问题")]),e._v("：")]),e._v(" "),s("ol",[s("li",[e._v("缓存续命：当分布式锁快要到期，业务还没有执行完的时候，需要给所续命。")]),e._v(" "),s("li",[e._v("Redis集群可能出现的问题，异步复制会造成锁丢失：主节点刚刚告诉线程加锁成功，还没来得及把这个数据复制给从节点就挂了。")])]),e._v(" "),s("h4",{attrs:{id:"_2-redis和zookeeper分布式锁的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-redis和zookeeper分布式锁的区别"}},[e._v("#")]),e._v(" 2 Redis和Zookeeper分布式锁的区别")]),e._v(" "),s("p",[e._v("Redis集群保证了AP：先通知线程加锁成功，再将数据复制给从节点。")]),e._v(" "),s("p",[e._v("Zookeeper集群保证了CP：先将数据复制给从节点，全部复制完毕后再告诉线程加锁成功，虽然安全，但效率低。")]),e._v(" "),s("h4",{attrs:{id:"_3-redission"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-redission"}},[e._v("#")]),e._v(" 3 Redission")]),e._v(" "),s("p",[e._v("RedLock的实现，用于实现分布式锁，可以方便解决分布式锁的各类问题。")])])}),[],!1,null,null,null);s.default=r.exports}}]);