(window.webpackJsonp=window.webpackJsonp||[]).push([[73],{397:function(a,t,s){"use strict";s.r(t);var n=s(3),e=Object(n.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"spring常见面试问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring常见面试问题"}},[a._v("#")]),a._v(" Spring常见面试问题")]),a._v(" "),t("h4",{attrs:{id:"_1-什么是spring框架"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么是spring框架"}},[a._v("#")]),a._v(" 1 什么是Spring框架")]),a._v(" "),t("p",[a._v("开源轻量级Java开发框架，Spring框架指的是Spring Framework，它是很多模块的集合，使用这些模块可以很方便的协助我们开发。")]),a._v(" "),t("p",[a._v("核心思想：不重新造轮子，开箱即用。")]),a._v(" "),t("h4",{attrs:{id:"_3-什么是bean"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-什么是bean"}},[a._v("#")]),a._v(" 3 什么是bean？")]),a._v(" "),t("p",[a._v("简单来说，bean代指的就是那些被IoC容器所管理的对象。我们需要告诉IoC容器帮助我们管理哪些对象，这个是通过配置元数据来定义的。配置元数据可以是XML文件、注解或Java类。")]),a._v(" "),t("div",{staticClass:"language-xml line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-xml"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("\x3c!-- Constructor-arg with 'value' attribute --\x3e")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),a._v("bean")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("id")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[a._v("=")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v('"')]),a._v("..."),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v('"')])]),a._v(" "),t("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("class")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[a._v("=")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v('"')]),a._v("..."),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v('"')])]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("\n   "),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),a._v("constructor-arg")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("value")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[a._v("=")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v('"')]),a._v("..."),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v('"')])]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("/>")])]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("</")]),a._v("bean")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br")])]),t("h4",{attrs:{id:"_4-bean的作用域有哪些"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-bean的作用域有哪些"}},[a._v("#")]),a._v(" 4 bean的作用域有哪些？")]),a._v(" "),t("ul",[t("li",[a._v("singleton：唯一bean实例，默认是单例的。")]),a._v(" "),t("li",[a._v("prototype：每次请求都会创建一个新的bean实例。")]),a._v(" "),t("li",[a._v("request：每次HTTP请求都会创建一个新的bean实例，该bean仅在当前HTTP request内有效。")]),a._v(" "),t("li",[a._v("session：每一次来自新session的HTTP请求都会产生一个新的bean，该bean仅在当前HTTP session内有效。")]),a._v(" "),t("li",[a._v("global-session：全局session作用域，")])]),a._v(" "),t("h4",{attrs:{id:"_5-单例bean的线程安全了解吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-单例bean的线程安全了解吗"}},[a._v("#")]),a._v(" 5 单例bean的线程安全了解吗？")]),a._v(" "),t("p",[a._v("单例bean存在线程安全问题，主要是因为当多个线程操作同一个对象的时候是存在资源竞争的。")]),a._v(" "),t("p",[a._v("解决办法：")]),a._v(" "),t("ol",[t("li",[a._v("在bean中尽量避免定义可变的成员变量。")]),a._v(" "),t("li",[a._v("在类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在ThreadLocal中。")])]),a._v(" "),t("p",[a._v("不过，大部分bean实际都是无状态的（没有实例变量）的（比如dao、Service），这种情况下，bean线程是安全的。")]),a._v(" "),t("h4",{attrs:{id:"_6-component和-bean的区别是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-component和-bean的区别是什么"}},[a._v("#")]),a._v(" 6 @Component和@Bean的区别是什么？")]),a._v(" "),t("ol",[t("li",[a._v("@Component注解作用于类，而@Bean作用于方法。")]),a._v(" "),t("li",[a._v("@Component通常是通过类路径扫描来自动侦测及自动装配到Spring容器。（我们可以使用@ComponentScan注解定义要扫描的路径从中找出表示了需要装配的类自动装配到Spring的bean容器中）。@Bean注解通常是我们在标有该注解的方法中定义产生整个bean，@Bean告诉了Spring这是某个类的实例，当我们需要用它的时候还给我。")]),a._v(" "),t("li",[a._v("@Bean注解比@Component注解的自定义性更强，而且很多地方我们只能通过@Bean注解来注册bean。比如当我们引用第三方库中的类需要装配到Spring容器时，则只能通过@Bean来实现。")])]),a._v(" "),t("h4",{attrs:{id:"_7-将一个类声明为bean的注解有哪些"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-将一个类声明为bean的注解有哪些"}},[a._v("#")]),a._v(" 7 将一个类声明为bean的注解有哪些？")]),a._v(" "),t("p",[a._v("一般使用@Autowired注解自动装配bean，要想把类表示成可用于@Autowired注解自动装配的bean的类，需用一下注解：")]),a._v(" "),t("ul",[t("li",[a._v("@Component：通用的注解，可标注任意类为Spring组件。如果一个Bean不知道属于哪个层，可以使用@Component注解标注。")]),a._v(" "),t("li",[a._v("@Repository：对应持久层的Dao层，数据库相关操作。")]),a._v(" "),t("li",[a._v("@Service：对应服务层，主要设计一些复杂的逻辑，需要用到Dao层。")]),a._v(" "),t("li",[a._v("@Controller：对应Spring MVC控制层，接受用户请求并调用Service层返回数据给前端。")])]),a._v(" "),t("h4",{attrs:{id:"_8-bean的生命周期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-bean的生命周期"}},[a._v("#")]),a._v(" 8 Bean的生命周期")]),a._v(" "),t("blockquote",[t("p",[a._v("Spring里面的一切都是bean，存储在Spring容器中。")])]),a._v(" "),t("p",[a._v("可以分为5各阶段：")]),a._v(" "),t("p",[a._v("创建前准备：从上下文和一些配置中查找并解析一些Bean有关的扩展实现，如init-method、destroy-method以及BeanFactoryPostProcessor，通过这些我们可以实现bean在加载过程中的一些扩展。")]),a._v(" "),t("p",[a._v("创建实例：通过反射去创建Bean的实例对象，并且扫描和解析Bean的一些属性。")]),a._v(" "),t("p",[a._v("依赖注入：如果被实例化的Bean存在依赖其他Bean对象的情况（@Autowired），则需要对这些依赖的Bean进行对象注入。执行扩展调用，比如BeanPostProcessors的before方法，InitializingBean的afterPropertieSet()方法。")]),a._v(" "),t("p",[a._v("容器缓存：把bean保存到容器中和Spring的缓存中，到这个阶段bean就可以被开发者使用了。这个阶段涉及到操作，如init-method以及BeanPostProcessors的after方法。")]),a._v(" "),t("p",[a._v("销毁实例：如果实现了DisposibleBean的destory()方法，或配置了destory-method方法，会在这个阶段被调用。")]),a._v(" "),t("h4",{attrs:{id:"_8-说一说对spring容器的了解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-说一说对spring容器的了解"}},[a._v("#")]),a._v(" 8 说一说对Spring容器的了解？")]),a._v(" "),t("p",[a._v("主要包含两种类型的容器：BeanFactory和ApplicationContext")]),a._v(" "),t("ul",[t("li",[a._v("BeanFactory：基础的IoC容器，默认采用延迟初始化策略。只有当客户端对象需要访问容器中的某个受管理对象啊的时候，才对该受管对象进行初始化以及依赖注入的操作。所以，相对来说，容器启动初期速度较快，所需要的资源有限。对于资源有限，且功能要求不是很严格的场景，BeanFactory是比较合适的IoC选择。")]),a._v(" "),t("li",[a._v("ApplicationContext：在BeanFactory基础上构建，ApplicationText所管理的对象，在该类型容器启动之后，默认全部初始化并绑定完成。所以，相对于BeanFactory来说，ApplicationContext要求更多的系统资源，启动时间会慢一些。在那些系统资源充足，并且要求更多的功能的场景中，ApplicationContext类型的容器是比较合适的选择。")])]),a._v(" "),t("h4",{attrs:{id:"_9-说说对beanfactory的了解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9-说说对beanfactory的了解"}},[a._v("#")]),a._v(" 9 说说对BeanFactory的了解？")]),a._v(" "),t("p",[a._v("BeanFactory是类的通用工程，它可以创建并管理各种类的对象。Spring称这些被创建和管理的Java对象为Bean。")]),a._v(" "),t("h4",{attrs:{id:"_8-spring中的设计模式-单例模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-spring中的设计模式-单例模式"}},[a._v("#")]),a._v(" 8 Spring中的设计模式——单例模式")]),a._v(" "),t("p",[a._v("在系统中，有一些对象其实我们只需要一个，比如：线程池、缓冲池、日志对象、驱动等对象。事实上，这一类对象只能有一个实例，如果制造出多个实例就可能会导致一些问题的产生，比如：程序行为异常、资源使用过量、不一致的结果。")]),a._v(" "),t("p",[a._v("使用单例的好处：")]),a._v(" "),t("ul",[t("li",[a._v("对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔开销；")]),a._v(" "),t("li",[a._v("由于new操作的次数减少，因而对系统内存的使用率也会降低，减轻GC压力，缩短GC停顿时间。")])]),a._v(" "),t("h4",{attrs:{id:"_7-spring事务的传播机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-spring事务的传播机制"}},[a._v("#")]),a._v(" 7 Spring事务的传播机制？")]),a._v(" "),t("ul",[t("li",[a._v("propagation_required：如果外部没有事务，就开启一个事务；如果外部存在一个事务，就加入到该事务中。适用于增删改。（常用）")]),a._v(" "),t("li",[a._v("propagation_supports：如果外部事务不存在，则不使用事务；如果外部存在一个事务，就加入到该事务中。适用于查询方法。（常用）")]),a._v(" "),t("li",[a._v("propagation_mandatory：如果外部事务不存在，抛出异常；如果外部存在一个事务，就加入到该事务中。")]),a._v(" "),t("li",[a._v("propagation_required_new：如果外部没有事务，就开启一个事务；如果外部存在一个事务，挂起外部事物，创建新的事物。")]),a._v(" "),t("li",[a._v("propagation_not_supported：如果外部没有事务，不开启事务；如果外部存在一个事务，挂起外部事物。")]),a._v(" "),t("li",[a._v("propagation_never：如果外部事务不存在，则不使用事务；如果外部存在一个事务，则抛出异常。")]),a._v(" "),t("li",[a._v("propagation_nested：嵌套事务，如果当前事务存在，则嵌套在事务中执行。如果当前事务不存在，则创建一个新事物。如果嵌套事务发送回滚，只回滚嵌套部分的事务。")])]),a._v(" "),t("h4",{attrs:{id:"autowired与-resource的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#autowired与-resource的区别"}},[a._v("#")]),a._v(" @Autowired与@Resource的区别")]),a._v(" "),t("ol",[t("li",[a._v("@Autowired是Spring提供的注解，@Resource是JDK提供的注解。")]),a._v(" "),t("li",[a._v("@Autowired只能按类型注入，Spring会自动在代码中找到与其类型匹配的Bean进行注入，如果存在多个Bean时需要使用@Qualifier指明Bean的名称；@Resource默认按名称注入，也支持按类型注入。")]),a._v(" "),t("li",[a._v("@Autowired按类型装配依赖对象，默认情况它要求依赖对象必须存在，如果允许null值，可以设置它required属性为false，如果想要使用按名称装配。可以结合@Qualifier注解一起使用。@Resouce有两个重要的属性：name和type。name属性指定byName，如果没有指定name属性，当注解标注在属性的setter方法上，即默认取字段的名称作为bean名称寻找依赖对象。需要注意的是，@Resouce如果没有指定name属性，并且按照默认的名称仍然找不到依赖对象时，@Resource注解会回退到按类型装配。但一旦指定了name属性，就只能按名称装配了。")])]),a._v(" "),t("h4",{attrs:{id:"_1-什么是循环依赖问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么是循环依赖问题"}},[a._v("#")]),a._v(" 1 什么是循环依赖问题？")]),a._v(" "),t("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://raw.githubusercontent.com/zouquchen/Images/main/imgs/image-20220630212344733.png",alt:"image-20220630212344733"}}),a._v(" "),t("p",[a._v("官网解释：https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-dependency-resolution")]),a._v(" "),t("p",[a._v("依赖的注入方式：构造方法注入（无法解决循环依赖）、Set注入（能够解决循环依赖）")]),a._v(" "),t("p",[a._v("默认的单例（singleton）的场景至此循环依赖；原型（Prototype）的场景不支持循环依赖，会报错。")]),a._v(" "),t("p",[a._v("Spring内部通过三级缓存来解决循环依赖问题，DefaultSingletonBeanRegistry。")]),a._v(" "),t("h4",{attrs:{id:"_2-三级缓存解决循环依赖问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-三级缓存解决循环依赖问题"}},[a._v("#")]),a._v(" 2 三级缓存解决循环依赖问题？")]),a._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("DefaultSingletonBeanRegistry")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("extends")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("SimpleAliasRegistry")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("implements")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("SingletonBeanRegistry")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v(" \n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("/** Cache of singleton objects: bean name to bean instance. */")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("final")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Map")]),t("span",{pre:!0,attrs:{class:"token generics"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v(" singletonObjects "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("ConcurrentHashMap")]),t("span",{pre:!0,attrs:{class:"token generics"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("256")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 一级缓存")]),a._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("/** Cache of singleton factories: bean name to ObjectFactory. */")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("final")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Map")]),t("span",{pre:!0,attrs:{class:"token generics"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("ObjectFactory")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("?")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v(" singletonFactories "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("HashMap")]),t("span",{pre:!0,attrs:{class:"token generics"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("16")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 三级缓存")]),a._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("/** Cache of early singleton objects: bean name to bean instance. */")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("final")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Map")]),t("span",{pre:!0,attrs:{class:"token generics"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v(" earlySingletonObjects "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("HashMap")]),t("span",{pre:!0,attrs:{class:"token generics"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("16")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("  "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 二级缓存")]),a._v("\n    \n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br"),t("span",{staticClass:"line-number"},[a._v("7")]),t("br"),t("span",{staticClass:"line-number"},[a._v("8")]),t("br"),t("span",{staticClass:"line-number"},[a._v("9")]),t("br"),t("span",{staticClass:"line-number"},[a._v("10")]),t("br"),t("span",{staticClass:"line-number"},[a._v("11")]),t("br"),t("span",{staticClass:"line-number"},[a._v("12")]),t("br")])]),t("ul",[t("li",[t("p",[a._v("第一级缓存（单例池）：singletonObjects")]),a._v(" "),t("p",[t("strong",[a._v("存放已经经历了完整生命周期的Bean对象")]),a._v("。")])]),a._v(" "),t("li",[t("p",[a._v("第二级缓存：earlySingletonObjects，早期单例对象的高速缓存")]),a._v(" "),t("p",[a._v("表示Bean的生命周期还没走完（Bean的属性还未填充）就把这个Bean存入该缓存中，也就是"),t("strong",[a._v("实例化但未初始化的bean放入该缓存里")]),a._v("。")])]),a._v(" "),t("li",[t("p",[a._v("第三级缓存：Map<String, ObjectFactory<?>> singletonFactories，单例工厂的高速缓存")]),a._v(" "),t("p",[a._v("存放可以生成Bean的工厂。假如A类实现了FactoryBean，那么依赖注入的时候不是A类，而是A类产生的Bean。")])])]),a._v(" "),t("p",[a._v("只有单例的Bean会通过三级缓存提前暴露来解决循环依赖的问题，而非单例的bean，每次从容器中获取都是一个新的对象，都会重新创建，所以非单例的bean是没有缓存的，不会将其放到三级缓存中。")]),a._v(" "),t("blockquote",[t("p",[a._v("实例化：内存中申请一块内存空间")]),a._v(" "),t("p",[a._v("初始化：属性填充")])]),a._v(" "),t("p",[t("strong",[a._v("简单过程")])]),a._v(" "),t("ol",[t("li",[t("p",[a._v("A创建过程需要B，于是A将自己放到三级缓存里面，去实例化B")])]),a._v(" "),t("li",[t("p",[a._v("B实例化的时候发现需要A，于是B先查一级缓存，没有，再查二级缓存，没有，再查三级缓存，找到了A，然后把三级缓存里面的A移动二级缓存里。")])]),a._v(" "),t("li",[t("p",[a._v("B初始化完毕，将自己放到一级缓存（此时B里面的A依然是创建中状态）。")])]),a._v(" "),t("li",[t("p",[a._v("继续创建A，此时B已经创建结束，直接从一级缓存里面拿到B，完成创建，并将A放到一级缓存中。")])])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/zouquchen/Images/main/imgs/%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96-16566843025461.png",alt:"三级缓存解决循环依赖"}})])])}),[],!1,null,null,null);t.default=e.exports}}]);