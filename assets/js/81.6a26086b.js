(window.webpackJsonp=window.webpackJsonp||[]).push([[81],{405:function(e,s,t){"use strict";t.r(s);var _=t(3),a=Object(_.a)({},(function(){var e=this,s=e._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"过期删除策略和缓存淘汰机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#过期删除策略和缓存淘汰机制"}},[e._v("#")]),e._v(" 过期删除策略和缓存淘汰机制")]),e._v(" "),s("blockquote",[s("p",[e._v("如果不设置redis内存大小后设置最大内存为0，在64位操作系统下不限制内存大小，在32位操作系统下最多使用3GB内存。")]),e._v(" "),s("p",[e._v("一般推荐设置内存为最大物理内存的四分之三")])]),e._v(" "),s("h4",{attrs:{id:"_1-内存满了会怎么样"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-内存满了会怎么样"}},[e._v("#")]),e._v(" 1 内存满了会怎么样？")]),e._v(" "),s("p",[e._v("设置maxmemory为1，然后set一个字符串，之后会报OOM的错误。")]),e._v(" "),s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/zouquchen/Images/main/imgs/image-20220706205435284.png",alt:"image-20220706205435284"}})]),e._v(" "),s("h4",{attrs:{id:"_2-redis给缓存数据设置过期时间有啥用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-redis给缓存数据设置过期时间有啥用"}},[e._v("#")]),e._v(" 2 Redis给缓存数据设置过期时间有啥用？")]),e._v(" "),s("ol",[s("li",[s("p",[e._v("因为内存是有限的，如果缓存中的所有数据都一直保存的话，很容易造成内存溢出的问题。")])]),e._v(" "),s("li",[s("p",[e._v("业务场景需要某个数据只在某一时间段内存在，比如短信验证码只能在1分钟内有效，用户登录的token只在1天内有效。")])])]),e._v(" "),s("h4",{attrs:{id:"_3-redis是如何判断数据是否过期的呢"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-redis是如何判断数据是否过期的呢"}},[e._v("#")]),e._v(" 3 Redis是如何判断数据是否过期的呢？")]),e._v(" "),s("p",[e._v("Redis通过一个叫过期字典（可以看作是hash表）来保存数据过期的时间。过期字典的键指向Redis数据库中的某个键，过期字典的值是一个long long类型的整数，保存了key所指向的数据库的过期时间（时间戳）。")]),e._v(" "),s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/zouquchen/Images/main/imgs/redis%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4.96c57f41.png",alt:"redis过期字典"}})]),e._v(" "),s("h4",{attrs:{id:"_12-过期数据的删除策略"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_12-过期数据的删除策略"}},[e._v("#")]),e._v(" 12 过期数据的删除策略？")]),e._v(" "),s("ol",[s("li",[e._v("定时删除：需要随时计算那些数据要过期了，CPU压力大。销毁CPU性能，影响数据的读写操作。（时间换空间）")]),e._v(" "),s("li",[e._v("惰性删除：数据过期不处理，等下次访问数据时，如果未过期返回数据，如果已过期删除数据返回null。对CPU最友好，但是可能回造成太多过期key没有被删除，对内存不友好。（空间换时间）")]),e._v(" "),s("li",[e._v("定期删除：前两种测率的折中，每隔一段时间抽取一批key执行删除过期key操作。并且，Redis底层会通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。")])]),e._v(" "),s("p",[e._v("但是，仅通过给key设置过期时间还是有问题的，因为还是可能存在定期删除和惰性删除漏掉了很多过期key的情况，这样就导致大量过期key堆积在内存中，然后就OOM了。使用Redis内存淘汰机制解决。")]),e._v(" "),s("h4",{attrs:{id:"_13-redis内存淘汰机制-mysql里有2000w数据-redis中只有20w数据-如何保证redis中的数据都是热点数据"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_13-redis内存淘汰机制-mysql里有2000w数据-redis中只有20w数据-如何保证redis中的数据都是热点数据"}},[e._v("#")]),e._v(" 13 Redis内存淘汰机制？（MySQL里有2000w数据，Redis中只有20w数据，如何保证Redis中的数据都是热点数据？）")]),e._v(" "),s("p",[e._v("Redis提供8种淘汰策略：")]),e._v(" "),s("ol",[s("li",[e._v("volatile-lru（least recently used）：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰。")]),e._v(" "),s("li",[e._v("volatie-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰。")]),e._v(" "),s("li",[e._v("volatile-random：从已设置过去时间的数据集中任意选择数据淘汰。")]),e._v(" "),s("li",[e._v("allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最少使用的key。（"),s("strong",[e._v("常用")]),e._v("）")]),e._v(" "),s("li",[e._v("allkeys-random：从数据集中任意选择数据淘汰。")]),e._v(" "),s("li",[e._v("no-eviction：禁止驱逐数据，当内存不足以容纳新写入数据时，新写入操作会报错。（"),s("strong",[e._v("默认")]),e._v("）")]),e._v(" "),s("li",[e._v("volatile-lfu（least frequently used）：从已设置过期时间的数据集中挑选最不经常使用的数据淘汰。")]),e._v(" "),s("li",[e._v("allkeys-lfu：当内存空间不足以容纳新写入数据时，在键空间中，移除最不经常使用的key。")])]),e._v(" "),s("blockquote",[s("p",[e._v("总结：")]),e._v(" "),s("ul",[s("li",[e._v("2个维度：过期键中筛选、所有键中筛选")]),e._v(" "),s("li",[e._v("4个方面：LRU、LFU、random、ttl")])])])])}),[],!1,null,null,null);s.default=a.exports}}]);