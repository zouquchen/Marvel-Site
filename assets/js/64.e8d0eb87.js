(window.webpackJsonp=window.webpackJsonp||[]).push([[64],{388:function(_,v,e){"use strict";e.r(v);var t=e(3),s=Object(t.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"mysql锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mysql锁"}},[_._v("#")]),_._v(" MySQL锁")]),_._v(" "),v("h4",{attrs:{id:"_1-锁的分类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-锁的分类"}},[_._v("#")]),_._v(" 1 锁的分类")]),_._v(" "),v("ul",[v("li",[_._v("共享锁（S锁）：假设事务T1对数据A加上共享锁，那么事务T2可以读数据A，不能修改数据A。")]),_._v(" "),v("li",[_._v("排他锁（X锁）：假设事务T1对数据A加上排他锁，那么事务T2不能读取数据A，不能修改数据A。")])]),_._v(" "),v("blockquote",[v("p",[_._v("T1获取记录的S锁，之后T2也可以获得该记录的S锁。")]),_._v(" "),v("p",[_._v("T1获取记录的X锁，之后T2即不可以获得该记录的X锁，也不可以获得S锁，都会被阻塞，直到T1提交事务释放X锁。")])]),_._v(" "),v("ul",[v("li",[_._v("意向共享锁（IS锁）：一个事务在获取（任何一行/或者全表）S锁之前，一定会先在所在的"),v("strong",[_._v("表")]),_._v("上加IS锁。")]),_._v(" "),v("li",[_._v("意向排他锁（IX锁）：一个事务在获取（任何一行/或者全表）X锁之前，一定会先在所在的"),v("strong",[_._v("表")]),_._v("上加IX锁。")])]),_._v(" "),v("blockquote",[v("p",[_._v("通过"),v("code",[_._v("update")]),_._v("、"),v("code",[_._v("delete")]),_._v("等语句加上的锁都是行级别的锁；")]),_._v(" "),v("p",[_._v("只由"),v("code",[_._v("LOCK TABLE ... READ")]),_._v("和"),v("code",[_._v("LOCK TABLE ... WRITE")]),_._v("才能申请表级别锁。")])]),_._v(" "),v("h4",{attrs:{id:"_2-意向锁存在的目的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-意向锁存在的目的"}},[_._v("#")]),_._v(" 2 意向锁存在的目的？")]),_._v(" "),v("p",[_._v("假设事务T1，用X锁来锁住了表上的几条记录，那么此时表上存在IX锁，即意向排他锁。那么此时事务T2要进行"),v("code",[_._v("LOCK TABLE ... WRITE")]),_._v("的表级别锁的请求，可以直接根据意向锁是否存在而判断是否有锁冲突，而不是去遍历所有的记录去查看有没有行级别的排他锁。")]),_._v(" "),v("h4",{attrs:{id:"_3-加锁的算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-加锁的算法"}},[_._v("#")]),_._v(" 3 加锁的算法？")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("Record Locks："),v("strong",[_._v("行锁")]),_._v("。该锁是对索引记录进行加锁！锁是加在索引上而不是行上的。innodb一定存在聚簇索引，因为行锁最终都会落到聚簇索引上。")])]),_._v(" "),v("li",[v("p",[_._v("Gap Locks："),v("strong",[_._v("间隙锁")]),_._v("，是对索引间隙加锁，间隙锁用于锁定一个范围，但不包含记录本身。它的作用是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生。在Read Uncommited和Read Commited隔离级别下，不会使用间隙锁。隔离级别为Repeatable Read和Serializable时，使用间隙锁。")])]),_._v(" "),v("li",[v("p",[_._v("Next-Key Locks：可以理解为Record Locks + 索引前面的Gap Locks。记住了，锁住的是索引的间隙！比如一个索引包含值，10，11，13和20。那么，间隙锁的范围如下")]),_._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[_._v("(negative infinity, 10]\n(10, 11]\n(11, 13]\n(13, 20]\n(20, positive infinity)\n")])]),_._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[_._v("1")]),v("br"),v("span",{staticClass:"line-number"},[_._v("2")]),v("br"),v("span",{staticClass:"line-number"},[_._v("3")]),v("br"),v("span",{staticClass:"line-number"},[_._v("4")]),v("br"),v("span",{staticClass:"line-number"},[_._v("5")]),v("br")])])])]),_._v(" "),v("h4",{attrs:{id:"_4-快照读和当前读"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-快照读和当前读"}},[_._v("#")]),_._v(" 4 快照读和当前读")]),_._v(" "),v("p",[_._v("在mysql中select分为快照读和当前读。")]),_._v(" "),v("p",[v("strong",[_._v("快照读")]),_._v("：")]),_._v(" "),v("p",[v("code",[_._v("select * from table where id = ?;")]),_._v("：读的是数据库记录的快照版本，不加锁的。")]),_._v(" "),v("p",[v("strong",[_._v("当前读")]),_._v("：")]),_._v(" "),v("p",[v("code",[_._v("select * from table where id = ? lock in share mode;")]),_._v("：会对读取数据加S锁。")]),_._v(" "),v("p",[v("code",[_._v("select * from table where id = ? for update")]),_._v("：会对读取数据加X锁。")]),_._v(" "),v("h4",{attrs:{id:"_5-表锁or行锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-表锁or行锁"}},[_._v("#")]),_._v(" 5 表锁or行锁")]),_._v(" "),v("h4",{attrs:{id:"_6-死锁的产生及解决策略"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-死锁的产生及解决策略"}},[_._v("#")]),_._v(" 6 死锁的产生及解决策略？")]),_._v(" "),v("p",[v("strong",[_._v("死锁")]),_._v("：两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的线程，若无外力作用，它们都无法推进下去。")]),_._v(" "),v("p",[v("strong",[_._v("系统解决策略")]),_._v("：")]),_._v(" "),v("ol",[v("li",[_._v("直接进入等待，直到超时。整个超时时间可以通过参数"),v("code",[_._v("innodb_lock_wait_timeou")]),_._v("来设置，默认为50s。")]),_._v(" "),v("li",[_._v("发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务的以继续执行。"),v("code",[_._v("innodb_deadlock_detect")]),_._v("的默认值本身就是on。")])]),_._v(" "),v("p",[v("strong",[_._v("人工解决策略")]),_._v("：")]),_._v(" "),v("ol",[v("li",[_._v("终止系统中的一个或多个死锁进程，打破循环。"),v("code",[_._v("kill 12345(进程Id);")])]),_._v(" "),v("li",[_._v("抢占资源。从一个或多个进程中抢占足够数量的资源，分配给死锁进程，打破死锁状态。")])])])}),[],!1,null,null,null);v.default=s.exports}}]);